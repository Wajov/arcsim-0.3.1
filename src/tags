!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/wajov/Projects/arcsim/src/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	/p5.9.20210905.0/
AccelStruct	collisionutil.cpp	/^AccelStruct::AccelStruct (const Mesh &mesh, bool ccd):$/;"	f	class:AccelStruct
AccelStruct	collisionutil.hpp	/^struct AccelStruct {$/;"	s
Action	main.cpp	/^    struct Action {$/;"	s	function:main	file:
Annotation	display.hpp	/^	Annotation(Face* f, Edge* e, Node* n, Vec3 c, Vec3 p, Vec3 d=Vec3(0)) : $/;"	f	struct:Annotation
Annotation	display.hpp	/^struct Annotation {$/;"	s
BLOCKVECTORS_HPP	blockvectors.hpp	/^#define BLOCKVECTORS_HPP$/;"	d
BOX	bvh.hpp	/^#define BOX /;"	d
BREAKING_HPP	breaking.hpp	/^#define BREAKING_HPP$/;"	d
BVHCallback	collisionutil.hpp	/^typedef void (*BVHCallback) (const Face *face0, const Face *face1);$/;"	t	typeref:typename:void (*)(const Face * face0,const Face * face1)
BVHNode	collisionutil.hpp	/^typedef DeformBVHNode BVHNode;$/;"	t	typeref:typename:DeformBVHNode
BVHTree	collisionutil.hpp	/^typedef DeformBVHTree BVHTree;$/;"	t	typeref:typename:DeformBVHTree
Bary	separate.cpp	/^typedef Vec3 Bary; \/\/ barycentric coordinates$/;"	t	typeref:typename:Vec3	file:
Bary	separateobs.cpp	/^typedef Vec3 Bary; \/\/ barycentric coordinates$/;"	t	namespace:SO	typeref:typename:Vec3	file:
BendingData	dde.hpp	/^struct BendingData {double d[3][5];};$/;"	s
BodyFrame	mot_parser.hpp	/^struct BodyFrame$/;"	s
BodyFrameVector	mot_parser.hpp	/^typedef std::vector<BodyFrame> BodyFrameVector;$/;"	t	typeref:typename:std::vector<BodyFrame>
BodyVector	mot_parser.hpp	/^typedef std::vector<BodyFrameVector> BodyVector; $/;"	t	typeref:typename:std::vector<BodyFrameVector>
Box	conf.cpp	/^    Box () {}$/;"	f	struct:Box	file:
Box	conf.cpp	/^    Box (const Vec2 &umin, const Vec2 &umax): umin(umin), umax(umax) {}$/;"	f	struct:Box	file:
Box	conf.cpp	/^struct Box {$/;"	s	file:
CLOTH_HPP	cloth.hpp	/^#define CLOTH_HPP$/;"	d
COLLISIONUTIL_HPP	collisionutil.hpp	/^#define COLLISIONUTIL_HPP$/;"	d
COLLISION_HPP	collision.hpp	/^#define COLLISION_HPP$/;"	d
CONF_HPP	conf.hpp	/^#define CONF_HPP$/;"	d
CONSTRAINT_HPP	constraint.hpp	/^#define CONSTRAINT_HPP$/;"	d
Check	util.hpp	/^	enum Mode { Load = 0, Save, Check };$/;"	e	enum:Serialize::Mode
CircleHandle	handle.hpp	/^struct CircleHandle: public Handle {$/;"	s
Cloth	cloth.hpp	/^struct Cloth {$/;"	s
Collision	simulation.hpp	/^    enum {Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,$/;"	e	enum:Simulation::__anon8619f0600103
CollisionProxy	proxy.hpp	/^class CollisionProxy {$/;"	c
Constraint	constraint.hpp	/^struct Constraint {$/;"	s
Construct	bvh.cpp	/^DeformBVHTree::Construct()$/;"	f	class:DeformBVHTree	typeref:typename:void
DDE_HPP	dde.hpp	/^#define DDE_HPP$/;"	d
DEFXYR	tensormax.cpp	/^#define DEFXYR(/;"	d	file:
DISPLAYPHYSICS_HPP	displayphysics.hpp	/^#define DISPLAYPHYSICS_HPP$/;"	d
DISPLAYREPLAY_HPP	displayreplay.hpp	/^#define DISPLAYREPLAY_HPP$/;"	d
DISPLAYTESTING_HPP	displaytesting.hpp	/^#define DISPLAYTESTING_HPP$/;"	d
DISPLAY_HPP	display.hpp	/^#define DISPLAY_HPP$/;"	d
DTransformation	transformation.hpp	/^typedef std::pair<Transformation,Transformation> DTransformation;$/;"	t	typeref:typename:std::pair<Transformation,Transformation>
DYNAMICREMESH_HPP	dynamicremesh.hpp	/^#define DYNAMICREMESH_HPP$/;"	d
DeformBVHNode	bvh.cpp	/^DeformBVHNode::DeformBVHNode()$/;"	f	class:DeformBVHNode
DeformBVHNode	bvh.cpp	/^DeformBVHNode::DeformBVHNode(DeformBVHNode *parent, Face **lst, unsigned int lst_num, std::map<F/;"	f	class:DeformBVHNode
DeformBVHNode	bvh.cpp	/^DeformBVHNode::DeformBVHNode(DeformBVHNode *parent, Face *face, std::map<Face*,BOX>& tri_boxes)$/;"	f	class:DeformBVHNode
DeformBVHNode	bvh.hpp	/^class DeformBVHNode {$/;"	c
DeformBVHTree	bvh.cpp	/^DeformBVHTree::DeformBVHTree(DeformModel &mdl, bool ccd)$/;"	f	class:DeformBVHTree
DeformBVHTree	bvh.hpp	/^class DeformBVHTree {$/;"	c
DeformModel	bvh.hpp	/^typedef Mesh DeformModel;$/;"	t	typeref:typename:Mesh
Deterministic_sort	dynamicremesh.cpp	/^struct Deterministic_sort {$/;"	s	file:
Disk	tensormax.cpp	/^    Disk (): c(Vec2(0)), r(0) {}$/;"	f	struct:Disk	file:
Disk	tensormax.cpp	/^    Disk (const Vec2 &c, double r): c(c), r(r) {}$/;"	f	struct:Disk	file:
Disk	tensormax.cpp	/^struct Disk {$/;"	s	file:
DisplayMode	display.cpp	/^struct DisplayMode { string name; double scale; bool active; };$/;"	s	file:
Dm	mesh.hpp	/^    Mat3x3 Dm, invDm; \/\/ finite element matrix$/;"	m	struct:Face	typeref:typename:Mat3x3
ECHO	util.hpp	/^#define ECHO(/;"	d
EE	collision.cpp	/^    enum Type {VF, EE} type;$/;"	e	enum:Impact::Type	file:
EPSILON	util.hpp	/^#define EPSILON	/;"	d
Edge	mesh.hpp	/^    Edge () : index(-1), theta_ideal(0), damage(0) { n[0]=n[1]=0; adjf[0]=adjf[1]=0; }$/;"	f	struct:Edge
Edge	mesh.hpp	/^    explicit Edge (Node *node0, Node *node1, double theta_ideal, int preserve):$/;"	f	struct:Edge
Edge	mesh.hpp	/^struct Edge {$/;"	s
EdgeClipping	separate.cpp	/^    EdgeClipping () {t[0] = 0; t[1] = 1; edge[0] = edge[1] = NULL;}$/;"	f	struct:EdgeClipping	file:
EdgeClipping	separate.cpp	/^struct EdgeClipping {$/;"	s	file:
Eig	vectors.hpp	/^template <int n> struct Eig {$/;"	s
EmbedOpt	plasticity.cpp	/^    EmbedOpt (Cloth &cloth): cloth(cloth), mesh(cloth.mesh) {$/;"	f	struct:EmbedOpt	file:
EmbedOpt	plasticity.cpp	/^struct EmbedOpt: public NLOpt {$/;"	s	file:
EqCon	constraint.hpp	/^struct EqCon: public Constraint {$/;"	s
F	localopt.cpp	/^    mutable vector<Vec3> F;$/;"	m	struct:LocalOpt	typeref:typename:vector<Vec3>	file:
FILE_VERSION	io.cpp	/^const int FILE_VERSION = 1;$/;"	v	typeref:typename:const int
FORCEINLINE	bvh.hpp	/^#define FORCEINLINE /;"	d
Face	mesh.hpp	/^    Face () : material(0), flag(0), index(-1), a(0), m(0), damage(0) { $/;"	f	struct:Face
Face	mesh.hpp	/^    explicit Face (Vert *vert0, Vert *vert1, Vert *vert2, const Mat3x3& ps, $/;"	f	struct:Face
Face	mesh.hpp	/^struct Face {$/;"	s
FanPrecomp	sepstrength.cpp	/^struct FanPrecomp {$/;"	s	file:
FlagActive	mesh.hpp	/^	enum NodeFlags { FlagNone = 0, FlagActive = 1, FlagMayBreak = 2, $/;"	e	enum:Node::NodeFlags
FlagMayBreak	mesh.hpp	/^	enum NodeFlags { FlagNone = 0, FlagActive = 1, FlagMayBreak = 2, $/;"	e	enum:Node::NodeFlags
FlagNone	mesh.hpp	/^	enum NodeFlags { FlagNone = 0, FlagActive = 1, FlagMayBreak = 2, $/;"	e	enum:Node::NodeFlags
FlagResolveMax	mesh.hpp	/^                     FlagResolveUni = 4, FlagResolveMax = 8 };$/;"	e	enum:Node::NodeFlags
FlagResolveUni	mesh.hpp	/^                     FlagResolveUni = 4, FlagResolveMax = 8 };$/;"	e	enum:Node::NodeFlags
FloorProxy	proxy.cpp	/^FloorProxy::FloorProxy(Mesh& mesh){$/;"	f	class:FloorProxy
FloorProxy	proxy.hpp	/^class FloorProxy : public CollisionProxy {$/;"	c
Fracture	simulation.hpp	/^          PopFilter, Plasticity, Fracture, nModules};$/;"	e	enum:Simulation::__anon8619f0600103
GEOMETRY_HPP	geometry.hpp	/^#define GEOMETRY_HPP$/;"	d
GL_GLEXT_PROTOTYPES	opengl.hpp	/^#define GL_GLEXT_PROTOTYPES$/;"	d
GlueCon	constraint.hpp	/^struct GlueCon: public Constraint {$/;"	s
GlueHandle	handle.hpp	/^struct GlueHandle: public Handle {$/;"	s
GlutCallbacks	display.hpp	/^    GlutCallbacks (): idle(NULL), keyboard(NULL), special(NULL) {}$/;"	f	struct:GlutCallbacks
GlutCallbacks	display.hpp	/^struct GlutCallbacks {$/;"	s
HANDLE_HPP	handle.hpp	/^#define HANDLE_HPP$/;"	d
Handle	handle.hpp	/^struct Handle {$/;"	s
IO_HPP	io.hpp	/^#define IO_HPP$/;"	d
Impact	collision.cpp	/^    Impact () {}$/;"	f	struct:Impact	file:
Impact	collision.cpp	/^    Impact (Type type, const Node *n0, const Node *n1, const Node *n2,$/;"	f	struct:Impact	file:
Impact	collision.cpp	/^struct Impact {$/;"	s	file:
ImpactZone	collision.cpp	/^struct ImpactZone {$/;"	s	file:
IneqCon	constraint.hpp	/^struct IneqCon: public Constraint {$/;"	s
Ixn	separate.cpp	/^    Ixn () {}$/;"	f	struct:Ixn	file:
Ixn	separate.cpp	/^    Ixn (const Face *f0, const Face *f1)$/;"	f	struct:Ixn	file:
Ixn	separate.cpp	/^struct Ixn {  \/\/ intersection$/;"	s	file:
Ixn	separateobs.cpp	/^    Ixn () {}$/;"	f	struct:SO::Ixn	file:
Ixn	separateobs.cpp	/^    Ixn (const Face *f0, const Bary &b0, const Face *f1, const Bary &b1,$/;"	f	struct:SO::Ixn	file:
Ixn	separateobs.cpp	/^struct Ixn {\/\/ intersection$/;"	s	namespace:SO	file:
J	constraint.hpp	/^struct MeshHessV { Node* i; Node* j; Mat3x3 J; MeshHessV(Node *i, Node* j, const Mat3x3& J) : i(/;"	m	struct:MeshHessV	typeref:typename:Mat3x3
J	localopt.cpp	/^    mutable SpMat<Mat3x3> J;$/;"	m	struct:LocalOpt	typeref:typename:SpMat<Mat3x3>	file:
J	plasticity.cpp	/^    mutable SpMat<Mat3x3> J;$/;"	m	struct:EmbedOpt	typeref:typename:SpMat<Mat3x3>	file:
J	popfilter.cpp	/^    mutable SpMat<Mat3x3> J;$/;"	m	struct:PopOpt	typeref:typename:SpMat<Mat3x3>	file:
LAPACKE_dgesvd	vectors.cpp	/^#define LAPACKE_dgesvd /;"	d	file:
LAPACKE_dsyev	vectors.cpp	/^#define LAPACKE_dsyev /;"	d	file:
LAPACK_COL_MAJOR	vectors.cpp	/^#define LAPACK_COL_MAJOR /;"	d	file:
LAPACK_ROW_MAJOR	vectors.cpp	/^#define LAPACK_ROW_MAJOR /;"	d	file:
LOCALOPT_HPP	localopt.hpp	/^#define LOCALOPT_HPP$/;"	d
Line3	separate.cpp	/^typedef std::pair<Vec3, Vec3> Line3;$/;"	t	typeref:typename:std::pair<Vec3,Vec3>	file:
Load	util.hpp	/^	enum Mode { Load = 0, Save, Check };$/;"	e	enum:Serialize::Mode
LocalOpt	localopt.cpp	/^LocalOpt<s>::LocalOpt(vector<Node*>& nodes, const vector<Face*>& faces, const vector<Edge*>& edg/;"	f	class:LocalOpt
LocalOpt	localopt.cpp	/^struct LocalOpt: public NLOpt {$/;"	s	file:
MAGIC_HPP	magic.hpp	/^#define MAGIC_HPP$/;"	d
MAX	bvh.hpp	/^#define MAX(/;"	d
MESH_HPP	mesh.hpp	/^#define MESH_HPP$/;"	d
MIN	bvh.hpp	/^#define MIN(/;"	d
MISC_HPP	misc.hpp	/^#define MISC_HPP$/;"	d
MORPH_HPP	morph.hpp	/^#define MORPH_HPP$/;"	d
MOT_PARSER_HPP	mot_parser.hpp	/^#define MOT_PARSER_HPP$/;"	d
MS	geometry.hpp	/^enum Space {MS, PS, WS}; \/\/ material space, plastic space, world space$/;"	e	enum:Space
Magic	magic.hpp	/^    Magic ():$/;"	f	struct:Magic
Magic	magic.hpp	/^struct Magic {$/;"	s
Mat	vectors.hpp	/^    Mat () {for (int j = 0; j < n; j++) c[j] = VecmT(0);}$/;"	f	class:Mat
Mat	vectors.hpp	/^    explicit Mat (T x) {for (int j = 0; j < n; j++) {c[j] = VecmT(0); if (j < m) c[j][j] = x;}}$/;"	f	class:Mat
Mat	vectors.hpp	/^    explicit Mat (VecmT x, VecmT y) {static_assert(n==2); c[0] = x; c[1] = y;}$/;"	f	class:Mat
Mat	vectors.hpp	/^    explicit Mat (VecmT x, VecmT y, VecmT z) {static_assert(n==3); c[0] = x; c[1] = y; c[2] = z;/;"	f	class:Mat
Mat	vectors.hpp	/^    explicit Mat (VecmT x, VecmT y, VecmT z, VecmT w) {static_assert(n==4); c[0] = x; c[1] = y; /;"	f	class:Mat
Mat	vectors.hpp	/^template <int m, int n, typename T=double> class Mat {$/;"	c
Mat12x12	physics.cpp	/^typedef Mat<12,12> Mat12x12;$/;"	t	typeref:typename:Mat<12,12>	file:
Mat2x2	vectors.hpp	/^typedef Mat<2,2> Mat2x2;$/;"	t	typeref:typename:Mat<2,2>
Mat2x3	vectors.hpp	/^typedef Mat<2,3> Mat2x3;$/;"	t	typeref:typename:Mat<2,3>
Mat3x2	vectors.hpp	/^typedef Mat<3,2> Mat3x2;$/;"	t	typeref:typename:Mat<3,2>
Mat3x3	vectors.hpp	/^typedef Mat<3,3> Mat3x3;$/;"	t	typeref:typename:Mat<3,3>
Mat3x4	physics.cpp	/^typedef Mat<3,4> Mat3x4;$/;"	t	typeref:typename:Mat<3,4>	file:
Mat4x6	physics.cpp	/^typedef Mat<4,6> Mat4x6;$/;"	t	typeref:typename:Mat<4,6>	file:
Mat4x9	physics.cpp	/^typedef Mat<4,9> Mat4x9;$/;"	t	typeref:typename:Mat<4,9>	file:
Mat6x6	physics.cpp	/^typedef Mat<6,6> Mat6x6;$/;"	t	typeref:typename:Mat<6,6>	file:
Mat9x6	physics.cpp	/^typedef Mat<9,6> Mat9x6;$/;"	t	typeref:typename:Mat<9,6>	file:
Mat9x9	physics.cpp	/^typedef Mat<9,9> Mat9x9;$/;"	t	typeref:typename:Mat<9,9>	file:
MatTransposed	vectors.hpp	/^template <int m, int n, typename T> class MatTransposed : protected Mat<m,n,T> {$/;"	c
Material	cloth.hpp	/^struct Material {$/;"	s
MatmnT	vectors.hpp	/^#define MatmnT /;"	d
MatnmT	vectors.hpp	/^#define MatnmT /;"	d
MatnnT	vectors.hpp	/^#define MatnnT /;"	d
Mesh	mesh.hpp	/^    Mesh() : ref(0), parent(0), proxy(0) {};$/;"	f	struct:Mesh
Mesh	mesh.hpp	/^struct Mesh {$/;"	s
MeshGrad	constraint.hpp	/^typedef std::vector<MeshGradV> MeshGrad;$/;"	t	typeref:typename:std::vector<MeshGradV>
MeshGradV	constraint.hpp	/^struct MeshGradV { Node* node; Vec3 f; MeshGradV(Node* i, const Vec3& f) : node(i), f(f) {} };$/;"	f	struct:MeshGradV
MeshGradV	constraint.hpp	/^struct MeshGradV { Node* node; Vec3 f; MeshGradV(Node* i, const Vec3& f) : node(i), f(f) {} };$/;"	s
MeshHess	constraint.hpp	/^typedef std::vector<MeshHessV> MeshHess;$/;"	t	typeref:typename:std::vector<MeshHessV>
MeshHessV	constraint.hpp	/^struct MeshHessV { Node* i; Node* j; Mat3x3 J; MeshHessV(Node *i, Node* j, const Mat3x3& J) : i(/;"	f	struct:MeshHessV
MeshHessV	constraint.hpp	/^struct MeshHessV { Node* i; Node* j; Mat3x3 J; MeshHessV(Node *i, Node* j, const Mat3x3& J) : i(/;"	s
MeshSubset	subset.hpp	/^class MeshSubset {$/;"	c
Min	nearobs.cpp	/^    Min (): key(infinity), val() {}$/;"	f	struct:Min	file:
Min	nearobs.cpp	/^template <typename T> struct Min {$/;"	s	file:
Min	proximity.cpp	/^    Min (): key(infinity), val() {}$/;"	f	struct:Min	file:
Min	proximity.cpp	/^template <typename T> struct Min {$/;"	s	file:
Mode	util.hpp	/^	enum Mode { Load = 0, Save, Check };$/;"	g	struct:Serialize
Morph	morph.hpp	/^struct Morph {$/;"	s
Motion	transformation.hpp	/^typedef Spline<Transformation> Motion;$/;"	t	typeref:typename:Spline<Transformation>
MouseState	display.cpp	/^struct MouseState {$/;"	s	file:
NEAROBS_HPP	nearobs.hpp	/^#define NEAROBS_HPP$/;"	d
NEXT	util.hpp	/^#define NEXT(/;"	d
NLConOpt	optimization.hpp	/^struct NLConOpt { \/\/ nonlinear constrained optimization problem$/;"	s
NLOpt	optimization.hpp	/^struct NLOpt { \/\/ nonlinear optimization problem$/;"	s
NearPoint	nearobs.cpp	/^    NearPoint (double d, const Vec3 &x): d(d), x(x) {}$/;"	f	struct:NearPoint	file:
NearPoint	nearobs.cpp	/^struct NearPoint {$/;"	s	file:
Node	mesh.hpp	/^    Node () : uuid(uuid_src++), sep(0),label(0),flag(0),preserve(false),index(-1),a(0),m(0) {}$/;"	f	struct:Node
Node	mesh.hpp	/^    explicit Node (const Vec3 &y, const Vec3 &x, const Vec3 &v, int label, int flag, $/;"	f	struct:Node
Node	mesh.hpp	/^struct Node {$/;"	s
NodeFlags	mesh.hpp	/^	enum NodeFlags { FlagNone = 0, FlagActive = 1, FlagMayBreak = 2, $/;"	g	struct:Node
NodeHandle	handle.hpp	/^    NodeHandle (): activated(false) {}$/;"	f	struct:NodeHandle
NodeHandle	handle.hpp	/^struct NodeHandle: public Handle {$/;"	s
NormalOpt	collision.cpp	/^    NormalOpt (): zone(NULL), inv_m(0) {nvar = ncon = 0;}$/;"	f	struct:NormalOpt	file:
NormalOpt	collision.cpp	/^    NormalOpt (ImpactZone *zone): zone(zone), inv_m(0) {$/;"	f	struct:NormalOpt	file:
NormalOpt	collision.cpp	/^struct NormalOpt: public NLConOpt {$/;"	s	file:
OBSTACLE_HPP	obstacle.hpp	/^#define OBSTACLE_HPP$/;"	d
OPENGL_HPP	opengl.hpp	/^#define OPENGL_HPP$/;"	d
OPTIMIZATION_HPP	optimization.hpp	/^#define OPTIMIZATION_HPP$/;"	d
Obstacle	obstacle.hpp	/^    Obstacle (): start_time(0), end_time(infinity), activated(false) {}$/;"	f	struct:Obstacle
Obstacle	obstacle.hpp	/^struct Obstacle {$/;"	s
OptOptions	optimization.hpp	/^    OptOptions (): _max_iter(100), _eps_x(1e-6), _eps_f(1e-12), _eps_g(1e-6) {}$/;"	f	struct:OptOptions
OptOptions	optimization.hpp	/^struct OptOptions {$/;"	s
PARSE_MAGIC	conf.cpp	/^#define PARSE_MAGIC(/;"	d	file:
PHYSICS_HPP	physics.hpp	/^#define PHYSICS_HPP$/;"	d
PLASTICITY_HPP	plasticity.hpp	/^#define PLASTICITY_HPP$/;"	d
POPFILTER_HPP	popfilter.hpp	/^#define POPFILTER_HPP$/;"	d
PREV	util.hpp	/^#define PREV(/;"	d
PROXIMITY_HPP	proximity.hpp	/^#define PROXIMITY_HPP$/;"	d
PROXY_HPP	proxy.hpp	/^#define PROXY_HPP$/;"	d
PS	geometry.hpp	/^enum Space {MS, PS, WS}; \/\/ material space, plastic space, world space$/;"	e	enum:Space
Pane	display.hpp	/^    Pane (bool enable): lat(0), lon(0), offset(0), scale(0.5), enabled(enable), initialized(fals/;"	f	struct:Pane
Pane	display.hpp	/^struct Pane {$/;"	s
Physics	simulation.hpp	/^    enum {Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,$/;"	e	enum:Simulation::__anon8619f0600103
Plane	mesh.hpp	/^    Plane() {}$/;"	f	struct:Plane
Plane	mesh.hpp	/^    Plane(const Vec3& x0, const Vec3& n) : x0(x0), n(n) {}$/;"	f	struct:Plane
Plane	mesh.hpp	/^struct Plane {$/;"	s
Plasticity	simulation.hpp	/^          PopFilter, Plasticity, Fracture, nModules};$/;"	e	enum:Simulation::__anon8619f0600103
PlasticityStash	remesh.cpp	/^    PlasticityStash (vector<Face*> &faces, vector<Edge*> &edges)$/;"	f	struct:PlasticityStash	file:
PlasticityStash	remesh.cpp	/^struct PlasticityStash {$/;"	s	file:
Point	spline.hpp	/^    struct Point {double t; T x, v;};$/;"	s	class:Spline
PopFilter	simulation.hpp	/^          PopFilter, Plasticity, Fracture, nModules};$/;"	e	enum:Simulation::__anon8619f0600103
PopOpt	popfilter.cpp	/^    PopOpt (Cloth &cloth, const vector<Constraint*> &cons):$/;"	f	struct:PopOpt	file:
PopOpt	popfilter.cpp	/^struct PopOpt: public NLOpt {$/;"	s	file:
Proximity	simulation.hpp	/^    enum {Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,$/;"	e	enum:Simulation::__anon8619f0600103
Q	vectors.hpp	/^    Mat<n,n> Q;$/;"	m	struct:Eig	typeref:typename:Mat<n,n>
Quaternion	transformation.hpp	/^struct Quaternion {$/;"	s
REFERENCESHAPE_HPP	referenceshape.hpp	/^#define REFERENCESHAPE_HPP$/;"	d
REMESH_HPP	remesh.hpp	/^#define REMESH_HPP$/;"	d
REPORT	util.hpp	/^#define REPORT(/;"	d
REPORT_ARRAY	util.hpp	/^#define REPORT_ARRAY(/;"	d
ROTATE	display.cpp	/^    enum {ROTATE, TRANSLATE, SCALE} func;$/;"	e	enum:MouseState::__anonc1288a8c0103	file:
RUNPHYSICS_HPP	runphysics.hpp	/^#define RUNPHYSICS_HPP$/;"	d
Range	conf.cpp	/^    Range (double &min, double &max): min(min), max(max) {}$/;"	f	struct:Range	file:
Range	conf.cpp	/^struct Range {$/;"	s	file:
ReferenceLinear	referenceshape.cpp	/^ReferenceLinear::ReferenceLinear(const Mesh& mesh) {    $/;"	f	class:ReferenceLinear
ReferenceLinear	referenceshape.hpp	/^class ReferenceLinear : public ReferenceShape {$/;"	c
ReferenceMesh	referenceshape.cpp	/^ReferenceMesh::ReferenceMesh(const Mesh& mesh, const string& filename) {  $/;"	f	class:ReferenceMesh
ReferenceMesh	referenceshape.hpp	/^class ReferenceMesh : public ReferenceShape {$/;"	c
ReferenceShape	referenceshape.hpp	/^class ReferenceShape {$/;"	c
ReferenceSphere	referenceshape.cpp	/^ReferenceSphere::ReferenceSphere(const Mesh& mesh) {$/;"	f	class:ReferenceSphere
ReferenceSphere	referenceshape.cpp	/^ReferenceSphere::ReferenceSphere(const Vec3& _center, double _radius) : center(_center), radius(/;"	f	class:ReferenceSphere
ReferenceSphere	referenceshape.hpp	/^class ReferenceSphere : public ReferenceShape {$/;"	c
RemeshOp	remesh.hpp	/^struct RemeshOp {$/;"	s
Remeshing	cloth.hpp	/^struct Remeshing {$/;"	s
Remeshing	simulation.hpp	/^    enum {Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,$/;"	e	enum:Simulation::__anon8619f0600103
SCALE	display.cpp	/^    enum {ROTATE, TRANSLATE, SCALE} func;$/;"	e	enum:MouseState::__anonc1288a8c0103	file:
SEPARATEOBS_HPP	separateobs.hpp	/^#define SEPARATEOBS_HPP$/;"	d
SEPARATE_HPP	separate.hpp	/^#define SEPARATE_HPP$/;"	d
SEPSTRENGTH_HPP	sepstrength.hpp	/^#define SEPSTRENGTH_HPP$/;"	d
SIMULATION_HPP	simulation.hpp	/^#define SIMULATION_HPP$/;"	d
SLOpt	strainlimiting.cpp	/^    SLOpt (vector<Mesh*> &meshes, const vector<StrainLimit> &strain_limits,$/;"	f	struct:SLOpt	file:
SLOpt	strainlimiting.cpp	/^struct SLOpt: public NLConOpt {$/;"	s	file:
SO	separateobs.cpp	/^namespace SO {$/;"	n	file:
SPARSE_HPP	sparse.hpp	/^#define SPARSE_HPP$/;"	d
SPLINE_HPP	spline.hpp	/^#define SPLINE_HPP$/;"	d
STRAINLIMITING_HPP	strainlimiting.hpp	/^#define STRAINLIMITING_HPP$/;"	d
SUBSET_HPP	subset.hpp	/^#define SUBSET_HPP$/;"	d
SUPPORT_RINGS	breaking.cpp	/^const int SUPPORT_RINGS = 2;$/;"	v	typeref:typename:const int
SVD	vectors.hpp	/^template <int m, int n> struct SVD {$/;"	s
Save	util.hpp	/^	enum Mode { Load = 0, Save, Check };$/;"	e	enum:Serialize::Mode
Separation	simulation.hpp	/^    enum {Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,$/;"	e	enum:Simulation::__anon8619f0600103
SeparationOpt	separateobs.cpp	/^    SeparationOpt (const vector<Ixn> &ixns): ixns(ixns), inv_m(0) {$/;"	f	struct:SO::SeparationOpt	file:
SeparationOpt	separateobs.cpp	/^struct SeparationOpt: public NLConOpt {$/;"	s	namespace:SO	file:
Serialize	util.hpp	/^struct Serialize {$/;"	s
Simulation	simulation.hpp	/^struct Simulation {$/;"	s
SoftHandle	handle.hpp	/^struct SoftHandle: public Handle {$/;"	s
SpMat	sparse.hpp	/^    SpMat (): m(0), n(0), rows() {}$/;"	f	struct:SpMat
SpMat	sparse.hpp	/^    explicit SpMat (int m, int n): m(m), n(n), rows(m) {}$/;"	f	struct:SpMat
SpMat	sparse.hpp	/^template <typename T> struct SpMat {$/;"	s
SpVec	sparse.hpp	/^template <typename T> struct SpVec {$/;"	s
Sp_bend	mesh.hpp	/^    Mat3x3 Sp_bend; \/\/ plastic bending strain$/;"	m	struct:Face	typeref:typename:Mat3x3
Sp_str	mesh.hpp	/^    Mat3x3 Sp_str; \/\/ plastic stretching$/;"	m	struct:Face	typeref:typename:Mat3x3
Sp_str	remesh.cpp	/^    vector<Mat3x3> Sp_str;$/;"	m	struct:PlasticityStash	typeref:typename:vector<Mat3x3>	file:
Space	geometry.hpp	/^enum Space {MS, PS, WS}; \/\/ material space, plastic space, world space$/;"	g
Spline	spline.cpp	/^template class Spline< vector<double> >;$/;"	v	typeref:meta:class
Spline	spline.cpp	/^template class Spline<Transformation>;$/;"	v	typeref:meta:class
Spline	spline.cpp	/^template class Spline<Vec3>;$/;"	v	typeref:meta:class
Spline	spline.cpp	/^template class Spline<double>;$/;"	v	typeref:meta:class
Spline	spline.hpp	/^class Spline {$/;"	c
SplitNode	sepstrength.hpp	/^	SplitNode(Node* node) : node(node),sep(0) { faces[0] = faces[1] = NULL; normal[0] = normal[1]= /;"	f	struct:SplitNode
SplitNode	sepstrength.hpp	/^struct SplitNode {$/;"	s
Stats	util.hpp	/^    Stats (): sum(0) {}$/;"	f	struct:Stats
Stats	util.hpp	/^struct Stats {$/;"	s
StrainLimit	strainlimiting.hpp	/^    StrainLimit() : min(1), max(1) {}$/;"	f	struct:StrainLimit
StrainLimit	strainlimiting.hpp	/^    StrainLimit(double min, double max) : min(min), max(max) {}$/;"	f	struct:StrainLimit
StrainLimit	strainlimiting.hpp	/^struct StrainLimit {$/;"	s
StrainLimiting	simulation.hpp	/^    enum {Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,$/;"	e	enum:Simulation::__anon8619f0600103
StretchingData	dde.hpp	/^struct StretchingData {Vec4 d[2][5];};$/;"	s
StretchingSamples	dde.hpp	/^struct StretchingSamples {Vec4 s[40][40][40];};$/;"	s
TAUCS_HPP	taucs.hpp	/^#define TAUCS_HPP$/;"	d
TENSORMAX_HPP	tensormax.hpp	/^#define TENSORMAX_HPP$/;"	d
TRANSFORMATION_HPP	transformation.hpp	/^#define TRANSFORMATION_HPP$/;"	d
TRANSLATE	display.cpp	/^    enum {ROTATE, TRANSLATE, SCALE} func;$/;"	e	enum:MouseState::__anonc1288a8c0103	file:
Timer	timer.cpp	/^Timer::Timer (): last(0), total(0) {$/;"	f	class:Timer
Timer	timer.hpp	/^struct Timer {$/;"	s
Transformation	transformation.cpp	/^Transformation::Transformation(double factor) {$/;"	f	class:Transformation
Transformation	transformation.hpp	/^struct Transformation {$/;"	s
Type	collision.cpp	/^    enum Type {VF, EE} type;$/;"	g	struct:Impact	file:
U	vectors.hpp	/^    Mat<m,m> U;$/;"	m	struct:SVD	typeref:typename:Mat<m,m>
UTIL_HPP	util.hpp	/^#define UTIL_HPP$/;"	d
UnionFind	separate.cpp	/^    UnionFind (size_t n): parent(n), rank(n, 0) {$/;"	f	struct:UnionFind	file:
UnionFind	separate.cpp	/^struct UnionFind {$/;"	s	file:
VECTORS_HPP	vectors.hpp	/^#define VECTORS_HPP$/;"	d
VEC_CMP	util.hpp	/^#define VEC_CMP(/;"	d
VF	collision.cpp	/^    enum Type {VF, EE} type;$/;"	e	enum:Impact::Type	file:
Vec	vectors.hpp	/^    Vec () {for (int i = 0; i < n; i++) c[i] = 0;}$/;"	f	class:Vec
Vec	vectors.hpp	/^    explicit Vec (T v0, T v1, T v2, T v3, T v4, T v5) {static_assert(n==6); c[0] = v0; c[1] = v1/;"	f	class:Vec
Vec	vectors.hpp	/^    explicit Vec (T x) {for (int i = 0; i < n; i++) c[i] = x;}$/;"	f	class:Vec
Vec	vectors.hpp	/^    explicit Vec (T x, T y) {static_assert(n==2); c[0] = x; c[1] = y;}$/;"	f	class:Vec
Vec	vectors.hpp	/^    explicit Vec (T x, T y, T z) {static_assert(n==3); c[0] = x; c[1] = y; c[2] = z;}$/;"	f	class:Vec
Vec	vectors.hpp	/^    explicit Vec (T x, T y, T z, T w) {static_assert(n==4); c[0] = x; c[1] = y; c[2] = z; c[3] =/;"	f	class:Vec
Vec	vectors.hpp	/^template <int n, typename T=double> class Vec {$/;"	c
Vec12	physics.cpp	/^typedef Vec<12> Vec12;$/;"	t	typeref:typename:Vec<12>	file:
Vec2	vectors.hpp	/^typedef Vec<2> Vec2;$/;"	t	typeref:typename:Vec<2>
Vec3	vectors.hpp	/^typedef Vec<3> Vec3;$/;"	t	typeref:typename:Vec<3>
Vec4	dde.hpp	/^typedef Vec<4> Vec4;$/;"	t	typeref:typename:Vec<4>
Vec4	mot_parser.hpp	/^typedef Vec<4> Vec4;$/;"	t	typeref:typename:Vec<4>
Vec9	physics.cpp	/^typedef Vec<9> Vec9;$/;"	t	typeref:typename:Vec<9>	file:
VecmT	vectors.hpp	/^#define VecmT /;"	d
VecnT	vectors.hpp	/^#define VecnT /;"	d
Velocity	conf.cpp	/^struct Velocity {Vec3 v, w; Vec3 o;};$/;"	s	file:
Vert	mesh.hpp	/^    Vert () : node(0),index(-1) {}$/;"	f	struct:Vert
Vert	mesh.hpp	/^    explicit Vert (const Vec3 &u):$/;"	f	struct:Vert
Vert	mesh.hpp	/^struct Vert {$/;"	s
Vt	vectors.hpp	/^    Mat<n,n> Vt;$/;"	m	struct:SVD	typeref:typename:Mat<n,n>
WINPORT_HPP	winport.hpp	/^#define WINPORT_HPP$/;"	d
WS	geometry.hpp	/^enum Space {MS, PS, WS}; \/\/ material space, plastic space, world space$/;"	e	enum:Space
Weights	morph.hpp	/^    typedef std::vector<double> Weights;$/;"	t	struct:Morph	typeref:typename:std::vector<double>
Wind	simulation.hpp	/^struct Wind {$/;"	s
_USE_MATH_DEFINES	winport.hpp	/^#define _USE_MATH_DEFINES /;"	d
__TIMER_H	timer.hpp	/^#define __TIMER_H$/;"	d
__align	vectors.hpp	/^#define __align(/;"	d
__anon8619f0600103	simulation.hpp	/^    enum {Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,$/;"	g	struct:Simulation
__anonc1288a8c0103	display.cpp	/^    enum {ROTATE, TRANSLATE, SCALE} func;$/;"	g	struct:MouseState	file:
_active	bvh.hpp	/^    bool _active;$/;"	m	class:DeformBVHNode	typeref:typename:bool
_box	bvh.hpp	/^	BOX _box;$/;"	m	class:DeformBVHNode	typeref:typename:BOX
_ccd	bvh.hpp	/^    bool _ccd;$/;"	m	class:DeformBVHTree	typeref:typename:bool
_dist	bvh.hpp	/^	float _dist[18];$/;"	m	class:kDOP18	typeref:typename:float[18]
_eps_f	optimization.hpp	/^    double _eps_x, _eps_f, _eps_g;$/;"	m	struct:OptOptions	typeref:typename:double
_eps_g	optimization.hpp	/^    double _eps_x, _eps_f, _eps_g;$/;"	m	struct:OptOptions	typeref:typename:double
_eps_x	optimization.hpp	/^    double _eps_x, _eps_f, _eps_g;$/;"	m	struct:OptOptions	typeref:typename:double
_face	bvh.hpp	/^	Face *_face;$/;"	m	class:DeformBVHNode	typeref:typename:Face *
_left	bvh.hpp	/^	DeformBVHNode *_left;$/;"	m	class:DeformBVHNode	typeref:typename:DeformBVHNode *
_max_iter	optimization.hpp	/^    int _max_iter;$/;"	m	struct:OptOptions	typeref:typename:int
_mdl	bvh.hpp	/^	DeformModel		*_mdl;$/;"	m	class:DeformBVHTree	typeref:typename:DeformModel *
_p	bvh.cpp	/^	float _p;$/;"	m	class:aap	typeref:typename:float	file:
_parent	bvh.hpp	/^	DeformBVHNode *_parent;$/;"	m	class:DeformBVHNode	typeref:typename:DeformBVHNode *
_right	bvh.hpp	/^	DeformBVHNode *_right;$/;"	m	class:DeformBVHNode	typeref:typename:DeformBVHNode *
_root	bvh.hpp	/^	DeformBVHNode	*_root;$/;"	m	class:DeformBVHTree	typeref:typename:DeformBVHNode *
_xyz	bvh.cpp	/^	char _xyz;$/;"	m	class:aap	typeref:typename:char	file:
a	constraint.hpp	/^    double a; \/\/ area$/;"	m	struct:IneqCon	typeref:typename:double
a	mesh.hpp	/^    double a, m; \/\/ area, mass$/;"	m	struct:Face	typeref:typename:double
a	mesh.hpp	/^    double a, m; \/\/ area, mass$/;"	m	struct:Node	typeref:typename:double
a0	popfilter.cpp	/^    vector<Vec3> x0, a0;$/;"	m	struct:PopOpt	typeref:typename:vector<Vec3>	file:
aap	bvh.cpp	/^	FORCEINLINE aap(const BOX &total) {$/;"	f	class:aap	typeref:typename:FORCEINLINE	file:
aap	bvh.cpp	/^class aap {$/;"	c	file:
acceleration	mesh.hpp	/^    Vec3 acceleration;$/;"	m	struct:Node	typeref:typename:Vec3
activate_nodes	mesh.cpp	/^void activate_nodes(vector<Node*>& nodes) {$/;"	f	typeref:typename:void
activated	handle.hpp	/^    bool activated;$/;"	m	struct:NodeHandle	typeref:typename:bool
activated	obstacle.hpp	/^    bool activated;$/;"	m	struct:Obstacle	typeref:typename:bool
active	collision.cpp	/^    bool active;$/;"	m	struct:ImpactZone	typeref:typename:bool	file:
active	display.cpp	/^struct DisplayMode { string name; double scale; bool active; };$/;"	m	struct:DisplayMode	typeref:typename:bool	file:
active	handle.hpp	/^    bool active (double t) {return t >= start_time && t <= end_time;}$/;"	f	struct:Handle	typeref:typename:bool
active	mesh.hpp	/^    inline bool active() const { return flag & FlagActive; }$/;"	f	struct:Node	typeref:typename:bool
active_nodes	subset.hpp	/^	std::vector<Node*> active_nodes;$/;"	m	class:MeshSubset	typeref:typename:std::vector<Node * >
add	display.hpp	/^	static void add(Edge* e, Vec3 c = Vec3(1,0,0)) { list.push_back(Annotation(0,e,0,c,Vec3(0))); }$/;"	f	struct:Annotation	typeref:typename:void
add	display.hpp	/^	static void add(Face* f, Vec3 c = Vec3(1,0,0)) { list.push_back(Annotation(f,0,0,c,Vec3(0))); }$/;"	f	struct:Annotation	typeref:typename:void
add	display.hpp	/^	static void add(Node* n, Vec3 c = Vec3(1,0,0)) { list.push_back(Annotation(0,0,n,c,Vec3(0))); }$/;"	f	struct:Annotation	typeref:typename:void
add	display.hpp	/^	static void add(Vec3 pos, Vec3 c = Vec3(1,0,0)) { list.push_back(Annotation(0,0,0,c,pos)); }$/;"	f	struct:Annotation	typeref:typename:void
add	display.hpp	/^	static void add(Vec3 pos, Vec3 dir, Vec3 c = Vec3(1,0,0)) { list.push_back(Annotation(0,0,0,c,p/;"	f	struct:Annotation	typeref:typename:void
add	lsnewton.cpp	/^static void add (vector<double> &v, double a, const vector<double> &x,$/;"	f	typeref:typename:void	file:
add	mesh.cpp	/^void Mesh::add (Edge *edge) {$/;"	f	class:Mesh	typeref:typename:void
add	mesh.cpp	/^void Mesh::add (Face *face) {$/;"	f	class:Mesh	typeref:typename:void
add	mesh.cpp	/^void Mesh::add (Node *node) {$/;"	f	class:Mesh	typeref:typename:void
add	mesh.cpp	/^void Mesh::add (Vert *vert) {$/;"	f	class:Mesh	typeref:typename:void
add	nearobs.cpp	/^    void add (double key, T val) {$/;"	f	struct:Min	typeref:typename:void	file:
add	proximity.cpp	/^    void add (double key, T val) {$/;"	f	struct:Min	typeref:typename:void	file:
add	trustregion.cpp	/^static void add (vector<double> &v, const vector<double> &x,$/;"	f	typeref:typename:void	file:
add	trustregion.cpp	/^static void add (vector<double> &v, double a, const vector<double> &x,$/;"	f	typeref:typename:void	file:
add	util.cpp	/^void Stats::add (double x) {$/;"	f	class:Stats	typeref:typename:void
add_all	remesh.cpp	/^template <class T> static void add_all(const vector<T>& a, Mesh& m) { for(size_t i=0; i<a.size()/;"	f	typeref:typename:void	file:
add_constraint_forces	physics.cpp	/^void add_constraint_forces (const vector<Constraint*> &cons,$/;"	f	typeref:typename:void
add_edges_if_needed	mesh.cpp	/^void add_edges_if_needed (Mesh &mesh, const Face *face) {$/;"	f	typeref:typename:void
add_external_forces	physics.cpp	/^void add_external_forces (const vector<Node*>& nodes, const vector<Face*>& faces, const Vec3 &gr/;"	f	typeref:typename:void
add_forces	handle.cpp	/^void SoftHandle::add_forces(double t, vector<Vec3> &fext, vector<Mat3x3>& Jext) {$/;"	f	class:SoftHandle	typeref:typename:void
add_forces	handle.hpp	/^    virtual void add_forces(double t, std::vector<Vec3> &fext, std::vector<Mat3x3>& Jext) {}$/;"	f	struct:Handle	typeref:typename:void
add_friction_forces	physics.cpp	/^void add_friction_forces (const vector<Constraint*> cons,$/;"	f	typeref:typename:void
add_gradient	separate.cpp	/^void add_gradient (const Face *face0, const Edge *edge0, const Face *face1,$/;"	f	typeref:typename:void
add_impacts	collision.cpp	/^void add_impacts (const vector<Impact> &impacts, vector<ImpactZone*> &zones) {$/;"	f	typeref:typename:void
add_internal_forces	physics.cpp	/^void add_internal_forces (const vector<Face*>& faces, const vector<Edge*>& edges,$/;"	f	typeref:typename:double internal_energy double internal_energy void
add_jitter	magic.hpp	/^    bool add_jitter;$/;"	m	struct:Magic	typeref:typename:bool
add_jitter	simulation.cpp	/^void add_jitter (Simulation& sim) { $/;"	f	typeref:typename:void
add_morph_forces	physics.cpp	/^void add_morph_forces (const Cloth &cloth, const Morph &morph, double t,$/;"	f	typeref:typename:void
add_position_constraints	handle.cpp	/^void add_position_constraints (const Node *node, const Vec3 &x, double stiff,$/;"	f	typeref:typename:void
add_proximity	proximity.cpp	/^void add_proximity (const Edge *edge0, const Edge *edge1) {$/;"	f	typeref:typename:void
add_proximity	proximity.cpp	/^void add_proximity (const Node *node, const Face *face) {$/;"	f	typeref:typename:void
add_proximity	proximity.cpp	/^void add_proximity(Node *node, Edge* edge) {$/;"	f	typeref:typename:void
add_strain_row	strainlimiting.cpp	/^void add_strain_row (const Mat3x3 &sg, const Face *face,$/;"	f	typeref:typename:void
add_submat	optimization.hpp	/^inline void add_submat (SpMat<double> &A, int i, int j, const Mat3x3 &Aij) {$/;"	f	typeref:typename:void
add_submat	physics.cpp	/^template <int m> void add_submat (const Mat<m*3,m*3> &Asub, const Vec<m,int> &ix, SpMat<Mat3x3> /;"	f	typeref:typename:void
add_subvec	optimization.hpp	/^inline void add_subvec (double *x, int i, const Vec3 &xi) {$/;"	f	typeref:typename:void
add_subvec	optimization.hpp	/^template <int n> void add_subvec (double *x, int i, const Vec<n> &xi) {$/;"	f	typeref:typename:void
add_subvec	physics.cpp	/^template <int m> void add_subvec (const Vec<m*3> &bsub, const Vec<m,int> &ix, vector<Vec3> &b) {$/;"	f	typeref:typename:void
added_edges	remesh.hpp	/^    std::vector<Edge*> added_edges, removed_edges;$/;"	m	struct:RemeshOp	typeref:typename:std::vector<Edge * >
added_faces	remesh.hpp	/^    std::vector<Face*> added_faces, removed_faces;$/;"	m	struct:RemeshOp	typeref:typename:std::vector<Face * >
added_nodes	remesh.hpp	/^    std::vector<Node*> added_nodes, removed_nodes;$/;"	m	struct:RemeshOp	typeref:typename:std::vector<Node * >
added_verts	remesh.hpp	/^    std::vector<Vert*> added_verts, removed_verts;$/;"	m	struct:RemeshOp	typeref:typename:std::vector<Vert * >
adj_face	mesh.hpp	/^inline Face *adj_face (const Face* face0, int num) {$/;"	f	typeref:typename:Face *
adjacent	separate.cpp	/^bool adjacent (const Face *face0, const Face *face1) {$/;"	f	typeref:typename:bool
adjacent	separateobs.cpp	/^bool adjacent (const Face *face0, const Face *face1) {$/;"	f	namespace:SO	typeref:typename:bool
adjacent_vert	dynamicremesh.cpp	/^Vert *adjacent_vert (const Node *node, const Vert *vert) {$/;"	f	typeref:typename:Vert *
adje	mesh.hpp	/^    Edge *adje[3]; \/\/ adjacent edges$/;"	m	struct:Face	typeref:typename:Edge * [3]
adje	mesh.hpp	/^    std::vector<Edge*> adje; \/\/ adjacent edges$/;"	m	struct:Node	typeref:typename:std::vector<Edge * >
adjf	mesh.hpp	/^    Face *adjf[2]; \/\/ adjacent faces$/;"	m	struct:Edge	typeref:typename:Face * [2]
adjf	mesh.hpp	/^    std::vector<Face*> adjf; \/\/ adjacent faces$/;"	m	struct:Vert	typeref:typename:std::vector<Face * >
advance_frame	simulation.cpp	/^void advance_frame (Simulation &sim) {$/;"	f	typeref:typename:void
advance_step	simulation.cpp	/^void advance_step (Simulation &sim) {	$/;"	f	typeref:typename:void
alglib_linear_solve	taucs.cpp	/^vector<double> alglib_linear_solve(const SpMat<double>& A, const vector<double>& b) {$/;"	f	typeref:typename:vector<double>
alglib_linear_solve_vec	taucs.cpp	/^vector<Vec<C> > alglib_linear_solve_vec(const SpMat<Mat<C,C> >& A, const vector<Vec<C> >& b) {$/;"	f	typeref:typename:vector<Vec<C>>
aligned_free	vectors.hpp	/^inline void aligned_free(void *ptr)    { _aligned_free(ptr); }$/;"	f	typeref:typename:void
aligned_free	vectors.hpp	/^inline void aligned_free(void *ptr)    { free(ptr); }$/;"	f	typeref:typename:void
alt_bending	cloth.hpp	/^    double alt_stretching, alt_bending, alt_poisson; \/\/ alternative material model$/;"	m	struct:Material	typeref:typename:double
alt_poisson	cloth.hpp	/^    double alt_stretching, alt_bending, alt_poisson; \/\/ alternative material model$/;"	m	struct:Material	typeref:typename:double
alt_stretching	cloth.hpp	/^    double alt_stretching, alt_bending, alt_poisson; \/\/ alternative material model$/;"	m	struct:Material	typeref:typename:double
ambient_light	display.cpp	/^void ambient_light (const Vec3 &a) {$/;"	f	typeref:typename:void
angle	dynamicremesh.cpp	/^double angle (const Vec3 &n1, const Vec3 &n2) {$/;"	f	typeref:typename:double
angle	io.cpp	/^static double angle (const Vec3 &x0, const Vec3 &x1, const Vec3 &x2) {$/;"	f	typeref:typename:double	file:
angle0	sepstrength.cpp	/^	double angle0, angle1;$/;"	m	struct:FanPrecomp	typeref:typename:double	file:
angle1	sepstrength.cpp	/^	double angle0, angle1;$/;"	m	struct:FanPrecomp	typeref:typename:double	file:
any_nearly_invalid	dynamicremesh.cpp	/^bool any_nearly_invalid (const vector<Edge*> edges) {$/;"	f	typeref:typename:bool
apollonius	tensormax.cpp	/^Disk apollonius (const Disk &disk1, const Disk &disk2, const Disk &disk3) {$/;"	f	typeref:typename:Disk
append	util.hpp	/^inline void append (std::vector<T> &xs, const std::vector<T> &ys) {$/;"	f	typeref:typename:void
append_frame	mot_parser.cpp	/^void append_frame(BodyVector &bodies, size_t body_index, const BodyFrame& bf) {$/;"	f	typeref:typename:void
apply	morph.cpp	/^void apply (const Morph &morph, double t) {$/;"	f	typeref:typename:void
apply	remesh.cpp	/^    void apply (vector<Face*> &faces, vector<Edge*> &edges) {$/;"	f	struct:PlasticityStash	typeref:typename:void	file:
apply	remesh.cpp	/^void RemeshOp::apply (Mesh &mesh) const {$/;"	f	class:RemeshOp	typeref:typename:void
apply	transformation.cpp	/^Vec3 Transformation::apply (const Vec3 &x) const {$/;"	f	class:Transformation	typeref:typename:Vec3
apply_dtrans	transformation.cpp	/^Vec3 apply_dtrans (const DTransformation &dtrans, const Vec3 &x0, Vec3 *vel) {$/;"	f	typeref:typename:Vec3
apply_dtrans_vec	transformation.cpp	/^Vec3 apply_dtrans_vec (const DTransformation &dtrans, const Vec3 &v0) {$/;"	f	typeref:typename:Vec3
apply_inelastic_projection	collision.cpp	/^void apply_inelastic_projection (ImpactZone *zone,$/;"	f	typeref:typename:void
apply_pop_filter	popfilter.cpp	/^void apply_pop_filter (Cloth &cloth, const vector<Constraint*> &cons,$/;"	f	typeref:typename:void
apply_transformation	mesh.cpp	/^void apply_transformation (Mesh& mesh, const Transformation& tr) {$/;"	f	typeref:typename:void
apply_transformation_onto	mesh.cpp	/^void apply_transformation_onto (const Mesh &start_state, Mesh &onto,$/;"	f	typeref:typename:void
apply_vec	transformation.cpp	/^Vec3 Transformation::apply_vec (const Vec3 &v) const {$/;"	f	class:Transformation	typeref:typename:Vec3
apply_velocity	conf.cpp	/^void apply_velocity (Mesh &mesh, const Velocity &vel) {$/;"	f	typeref:typename:void
apply_view	display.cpp	/^void apply_view (const Pane &view) {$/;"	f	typeref:typename:void
area	geometry.hpp	/^inline double area (const Face* face) { return area(face->v[0]->u, face->v[1]->u, face->v[2]->u)/;"	f	typeref:typename:double
area	geometry.hpp	/^inline double area (const Vec3& u0, const Vec3& u1, const Vec3& u2) { return 0.5*norm(cross(u1-u/;"	f	typeref:typename:double
area_cached	proximity.cpp	/^double area_cached (const Edge *edge) {$/;"	f	typeref:typename:double
area_cached	proximity.cpp	/^double area_cached (const Face *face) {$/;"	f	typeref:typename:double
area_cached	proximity.cpp	/^double area_cached (const Node *node) {$/;"	f	typeref:typename:double
aspect	geometry.cpp	/^double aspect (const Vec3& u0, const Vec3& u1, const Vec3& u2) {$/;"	f
aspect	geometry.hpp	/^inline double aspect (const Face* face) { return aspect(face->v[0]->u, face->v[1]->u, face->v[2]/;"	f	typeref:typename:double
aspect_min	cloth.hpp	/^    double aspect_min; \/\/ aspect ratio control$/;"	m	struct:Remeshing	typeref:typename:double
aspect_ratio	display.cpp	/^double aspect_ratio () {$/;"	f	typeref:typename:double
auglag_value_and_grad	auglag.cpp	/^static void auglag_value_and_grad (const real_1d_array &x, double &value,$/;"	f	typeref:typename:void	file:
augmented_lagrangian_method	auglag.cpp	/^void augmented_lagrangian_method (const NLConOpt &problem, OptOptions opt,$/;"	f	typeref:typename:void
axis	separate.cpp	/^    size_t axis;$/;"	m	struct:cmpOneAxis	typeref:typename:size_t	file:
b0	separateobs.cpp	/^    Bary b0, b1;$/;"	m	struct:SO::Ixn	typeref:typename:Bary	file:
b1	separateobs.cpp	/^    Bary b0, b1;$/;"	m	struct:SO::Ixn	typeref:typename:Bary	file:
b_md	tensormax.cpp	/^Disk b_md (const vector<Disk> &R) {$/;"	f	typeref:typename:Disk
b_minidisk	tensormax.cpp	/^Disk b_minidisk (const vector<Disk> &P, const vector<Disk> &R) {$/;"	f	typeref:typename:Disk
barycentric_coords	separate.cpp	/^Bary barycentric_coords (const Vec3 &x, const Face *face) {$/;"	f	typeref:typename:Bary
barycentric_weights	physics.cpp	/^Vec2 barycentric_weights (const Vec3 &x, const Vec3 &a, const Vec3 &b) {$/;"	f	typeref:typename:Vec2
base_mesh	obstacle.hpp	/^    Mesh base_mesh;$/;"	m	struct:Obstacle	typeref:typename:Mesh
bending_coeff	physics.cpp	/^double bending_coeff(const Edge* edge, double theta) {$/;"	f	typeref:typename:double
bending_energy	physics.cpp	/^double bending_energy (const Edge *edge) {$/;"	f	typeref:typename:double
bending_force	physics.cpp	/^pair<Mat12x12,Vec12> bending_force (const Edge *edge) {$/;"	f	typeref:typename:pair<Mat12x12,Vec12>
bending_stiffness	dde.cpp	/^double bending_stiffness (const Edge *edge, int side,$/;"	f	typeref:typename:double
blend	morph.cpp	/^Vec3 blend (const vector<Mesh> &targets, const vector<double> &w,$/;"	f	typeref:typename:Vec3
blend_with_previous	obstacle.cpp	/^void Obstacle::blend_with_previous (double t, double dt, double blend) {$/;"	f	class:Obstacle	typeref:typename:void
blockdiag	blockvectors.hpp	/^template <int bn, int m, int n, typename T> Mat<m*bn,n*bn,T> blockdiag (const Mat<m,n,T> &A) {$/;"	f	typeref:typename:Mat<m * bn,n * bn,T>
body_vector_to_transforms	mot_parser.cpp	/^vector<vector<Transformation> > body_vector_to_transforms(BodyVector& bodies) {$/;"	f	typeref:typename:vector<vector<Transformation>>
bodyframe_to_transformation	mot_parser.cpp	/^Transformation bodyframe_to_transformation(const BodyFrame& bodyFrame) {$/;"	f	typeref:typename:Transformation
box	bvh.cpp	/^DeformBVHTree::box()$/;"	f	class:DeformBVHTree	typeref:typename:BOX
break_node	breaking.cpp	/^bool break_node(SplitNode& split, MeshSubset& subset) {$/;"	f	typeref:typename:bool
build_cubic_spline	mot_parser.cpp	/^Spline<Transformation> build_cubic_spline($/;"	f	typeref:typename:Spline<Transformation>
build_face_normal_lookup	separateobs.cpp	/^void build_face_normal_lookup(map<const Face*,Vec3>& nmap, const vector<Mesh*>& meshes) {$/;"	f	namespace:SO	typeref:typename:void
build_node_lookup	util.cpp	/^void build_node_lookup(map<const Node*,Vec3>& nodemap, const vector<Mesh*>& meshes) {$/;"	f	typeref:typename:void
c	handle.hpp	/^    double c; \/\/ circumference$/;"	m	struct:CircleHandle	typeref:typename:double
c	tensormax.cpp	/^    Vec2 c;$/;"	m	struct:Disk	typeref:typename:Vec2	file:
c	vectors.hpp	/^    VecmT c[n];$/;"	m	class:Mat	typeref:typename:VecmT[]
can_collapse	dynamicremesh.cpp	/^bool can_collapse (Remeshing& remeshing, const Edge *edge, int i) {$/;"	f	typeref:typename:bool
cancel	remesh.cpp	/^void RemeshOp::cancel() {$/;"	f	class:RemeshOp	typeref:typename:void
cb	lsnewton.cpp	/^inline double cb (double x) {return x*x*x;}$/;"	f	typeref:typename:double
center	bvh.hpp	/^	FORCEINLINE float center(int i) const {$/;"	f	class:kDOP18	typeref:typename:FORCEINLINE float
center	bvh.hpp	/^	FORCEINLINE vec3f center() const { $/;"	f	class:kDOP18	typeref:typename:FORCEINLINE vec3f
center	display.hpp	/^    Vec3 center;$/;"	m	struct:Pane	typeref:typename:Vec3
center	handle.hpp	/^    Vec3 center;$/;"	m	struct:SoftHandle	typeref:typename:Vec3
center	proxy.hpp	/^    Node center;$/;"	m	class:FloorProxy	typeref:typename:Node
center	referenceshape.hpp	/^    Vec3 center;$/;"	m	class:ReferenceSphere	typeref:typename:Vec3
check	mesh.cpp	/^template <typename T1, typename T2> void check (const T1 *p1, const T2 *p2,$/;"	f	typeref:typename:void
check	util.hpp	/^	bool check() { return mode == Check; }	$/;"	f	struct:Serialize	typeref:typename:bool
check_that_contents_are_sane	mesh.cpp	/^bool check_that_contents_are_sane (const Mesh &mesh) {$/;"	f	typeref:typename:bool
check_that_pointers_are_sane	mesh.cpp	/^bool check_that_pointers_are_sane (const Mesh &mesh) {$/;"	f	typeref:typename:bool
clamp	util.hpp	/^template <typename T> T clamp (const T &x, const T &a, const T &b) {$/;"	f	typeref:typename:T
clamp_violation	auglag.cpp	/^inline double clamp_violation (double x, int sign) {$/;"	f	typeref:typename:double
clean_up_quaternions	transformation.cpp	/^void clean_up_quaternions (Motion &motion) {$/;"	f	typeref:typename:void
clear_flag	subset.cpp	/^void MeshSubset::clear_flag(int flag) {$/;"	f	class:MeshSubset	typeref:typename:void
clip_edge_to_face	separate.cpp	/^EdgeClipping clip_edge_to_face (const Edge *edge, const Face *face) {$/;"	f	typeref:typename:EdgeClipping
clone	proxy.cpp	/^CollisionProxy* FloorProxy::clone(Mesh& mesh) {$/;"	f	class:FloorProxy	typeref:typename:CollisionProxy *
closest_point	referenceshape.cpp	/^Vec3 ReferenceLinear::closest_point(const Vec3& p) {$/;"	f	class:ReferenceLinear	typeref:typename:Vec3
closest_point	referenceshape.cpp	/^Vec3 ReferenceMesh::closest_point(const Vec3& p) {$/;"	f	class:ReferenceMesh	typeref:typename:Vec3
closest_point	referenceshape.cpp	/^Vec3 ReferenceSphere::closest_point(const Vec3& p) {$/;"	f	class:ReferenceSphere	typeref:typename:Vec3
cloth	plasticity.cpp	/^    Cloth &cloth;$/;"	m	struct:EmbedOpt	typeref:typename:Cloth &	file:
cloth	popfilter.cpp	/^    Cloth &cloth;$/;"	m	struct:PopOpt	typeref:typename:Cloth &	file:
cloth_meshes	simulation.hpp	/^    std::vector<Mesh*> cloth_meshes, obstacle_meshes;$/;"	m	struct:Simulation	typeref:typename:std::vector<Mesh * >
cloths	simulation.hpp	/^    std::vector<Cloth> cloths;$/;"	m	struct:Simulation	typeref:typename:std::vector<Cloth>
cmpOneAxis	separate.cpp	/^    cmpOneAxis(size_t axis)$/;"	f	struct:cmpOneAxis	file:
cmpOneAxis	separate.cpp	/^struct cmpOneAxis {$/;"	s	file:
col	vectors.hpp	/^    inline VecmT &col (int j) {return c[j];}$/;"	f	class:Mat	typeref:typename:VecmT &
col	vectors.hpp	/^    inline const VecmT &col (int j) const {return c[j];}$/;"	f	class:Mat	typeref:typename:const VecmT &
collapse_edge	remesh.cpp	/^RemeshOp collapse_edge (Edge* edge, int i) {$/;"	f	typeref:typename:RemeshOp
collect_leaves	collisionutil.cpp	/^void collect_leaves (BVHNode *node, map<const Face*,BVHNode*> &leaves) {$/;"	f	typeref:typename:void
collect_upper_nodes	collisionutil.cpp	/^vector<BVHNode*> collect_upper_nodes (const vector<AccelStruct*> &accs,$/;"	f	typeref:typename:vector<BVHNode * >
collision	simulation.cpp	/^                 collision = Simulation::Collision,$/;"	v	typeref:typename:const int	file:
collision_response	collision.cpp	/^void collision_response (vector<Mesh*> &meshes, const vector<Constraint*> &cons,$/;"	f	typeref:typename:void
collision_step	simulation.cpp	/^void collision_step (Simulation &sim) {$/;"	f	typeref:typename:void
collision_stiffness	magic.hpp	/^    double handle_stiffness, collision_stiffness;$/;"	m	struct:Magic	typeref:typename:double
collision_test	collision.cpp	/^bool collision_test (Impact::Type type, const Node *node0, const Node *node1,$/;"	f	typeref:typename:bool
colmat	physics.cpp	/^template <int m> Mat<m,1> colmat (const Vec<m> &v) {$/;"	f	typeref:typename:Mat<m,1>
color	display.cpp	/^void color (const Vec3 &x) {$/;"	f	typeref:typename:void
color	display.hpp	/^	Vec3 color;$/;"	m	struct:Annotation	typeref:typename:Vec3
combine_tensors	magic.hpp	/^    bool combine_tensors;$/;"	m	struct:Magic	typeref:typename:bool
complain	conf.cpp	/^void complain (const Json::Value &json, const string &expected) {$/;"	f	typeref:typename:void
compression_metric	dynamicremesh.cpp	/^Mat2x2 compression_metric (const Face* face, const Mat3x3 &S2, const Mat3x2& UV, double c) {$/;"	f	typeref:typename:Mat2x2
compute_coplanar	separate.cpp	/^double compute_coplanar (const Face *face0, const Edge *edge0,$/;"	f	typeref:typename:double
compute_face_sizing	dynamicremesh.cpp	/^Mat3x3 compute_face_sizing (Remeshing& remeshing, const Face *face, const map<Node*,Plane> &plan/;"	f	typeref:typename:Mat3x3
compute_length_and_gradient	separate.cpp	/^void compute_length_and_gradient (Ixn &ixn) {$/;"	f	typeref:typename:void
compute_material	cloth.cpp	/^void compute_material (Material& mat, double Y) {$/;"	f	typeref:typename:void
compute_ms_data	mesh.cpp	/^void compute_ms_data (Face* face) {$/;"	f	typeref:typename:void
compute_ms_data	mesh.cpp	/^void compute_ms_data (Mesh &mesh) {$/;"	f	typeref:typename:void
compute_ms_data	mesh.cpp	/^void compute_ms_data (Node* node) {$/;"	f	typeref:typename:void
compute_ms_data	mesh.cpp	/^void compute_ms_data (vector<Face*>& faces) {$/;"	f	typeref:typename:void
compute_ms_data	mesh.cpp	/^void compute_ms_data (vector<Node*>& nodes) {$/;"	f	typeref:typename:void
compute_sigma	sepstrength.cpp	/^Mat3x3 compute_sigma(const Face* face) {\/*$/;"	f	typeref:typename:Mat3x3
compute_ws_data	mesh.cpp	/^void compute_ws_data (Face* face) {$/;"	f	typeref:typename:void
compute_ws_data	mesh.cpp	/^void compute_ws_data (Mesh &mesh) {$/;"	f	typeref:typename:void
compute_ws_data	mesh.cpp	/^void compute_ws_data (Node* node) {$/;"	f	typeref:typename:void
compute_ws_data	mesh.cpp	/^void compute_ws_data (vector<Face*>& faces) {$/;"	f	typeref:typename:void
compute_ws_data	mesh.cpp	/^void compute_ws_data (vector<Node*>& nodes) {$/;"	f	typeref:typename:void
con_grad	collision.cpp	/^void NormalOpt::con_grad (const double *x, int j, double factor,$/;"	f	class:NormalOpt	typeref:typename:void
con_grad	separateobs.cpp	/^void SeparationOpt::con_grad (const double *x, int j, double factor,$/;"	f	class:SO::SeparationOpt	typeref:typename:void
con_grad	strainlimiting.cpp	/^void SLOpt::con_grad (const double *x, int j, double factor,$/;"	f	class:SLOpt	typeref:typename:void
conflict	collision.cpp	/^bool conflict (const Impact &i0, const Impact &i1) {$/;"	f	typeref:typename:bool
connect	mesh.cpp	/^void connect (Vert *vert, Node *node) {$/;"	f	typeref:typename:void
connected_components	separate.cpp	/^vector< vector<Node*> > connected_components (const vector<Ixn> &ixns) {$/;"	f	typeref:typename:vector<vector<Node * >>
conold	strainlimiting.cpp	/^    vector<double> conold;$/;"	m	struct:SLOpt	typeref:typename:vector<double>	file:
cons	localopt.cpp	/^    vector<Constraint*> cons;    $/;"	m	struct:LocalOpt	typeref:typename:vector<Constraint * >	file:
cons	popfilter.cpp	/^    const vector<Constraint*> &cons;$/;"	m	struct:PopOpt	typeref:typename:const vector<Constraint * > &	file:
cons	strainlimiting.cpp	/^    const vector<Constraint*> &cons;$/;"	m	struct:SLOpt	typeref:typename:const vector<Constraint * > &	file:
cons	tensormax.cpp	/^template <typename T> vector<T> cons (const T &x, const vector<T> &v) {$/;"	f	typeref:typename:vector<T>
consistency	physics.cpp	/^static void consistency(vector<Vec3>& b, const string& name) {$/;"	f	typeref:typename:void	file:
consistency	simulation.cpp	/^static void consistency(const char* text) {$/;"	f	typeref:typename:void	file:
consistency_check	simulation.cpp	/^bool consistency_check = false;$/;"	v	typeref:typename:bool
constraint	collision.cpp	/^double NormalOpt::constraint (const double *x, int j, int &sign) const {$/;"	f	class:NormalOpt	typeref:typename:double
constraint	proxy.cpp	/^Constraint* FloorProxy::constraint(const Node* node) {$/;"	f	class:FloorProxy	typeref:typename:Constraint *
constraint	separateobs.cpp	/^double SeparationOpt::constraint (const double *x, int j, int &sign) const {$/;"	f	class:SO::SeparationOpt	typeref:typename:double
constraint	strainlimiting.cpp	/^double SLOpt::constraint (const double *x, int j, int &sign) const {$/;"	f	class:SLOpt	typeref:typename:double
constraint_energy	physics.cpp	/^double constraint_energy (const vector<Constraint*> &cons) {$/;"	f	typeref:typename:void add_internal_forces void add_internal_forces double
contains	constraint.cpp	/^bool EqCon::contains(Node* _node) { return node == _node; }$/;"	f	class:EqCon	typeref:typename:bool
contains	constraint.cpp	/^bool GlueCon::contains(Node* _node) { return nodes[0] == _node || nodes[1] == _node; }$/;"	f	class:GlueCon	typeref:typename:bool
contains	constraint.cpp	/^bool IneqCon::contains(Node *_node) {$/;"	f	class:IneqCon	typeref:typename:bool
copy_file	runphysics.cpp	/^void copy_file (const string &input, const string &output) {$/;"	f	typeref:typename:void
count_elements	mesh.hpp	/^template <typename Prim> inline int count_elements (const std::vector<Mesh*>& meshes) {$/;"	f	typeref:typename:int
create_accel_structs	collisionutil.cpp	/^vector<AccelStruct*> create_accel_structs (const vector<Mesh*> &meshes,$/;"	f	typeref:typename:vector<AccelStruct * >
create_vert_sizing	dynamicremesh.cpp	/^void create_vert_sizing (vector<Vert*>& verts, const map<Node*,Plane> &planes) {$/;"	f	typeref:typename:void
cross	dynamicremesh.cpp	/^double cross (const Vec2 &u, const Vec2 &v) {return u[0]*v[1] - u[1]*v[0];}$/;"	f	typeref:typename:double
cross	vectors.hpp	/^template <typename T> Vec<3,T> cross (const Vec<3,T> &u, const Vec<3,T> &v) {Vec<3,T> w; w[0] = /;"	f	typeref:typename:Vec<3,T>
curr_state_mesh	obstacle.hpp	/^    Mesh curr_state_mesh;$/;"	m	struct:Obstacle	typeref:typename:Mesh
current	display.cpp	/^Pane* Pane::current() { $/;"	f	class:Pane	typeref:typename:Pane *
curvature	geometry.cpp	/^template <Space s> Mat3x3 curvature (const Face *face) {$/;"	f
curvature	mesh.hpp	/^    Mat3x3 curvature; \/\/ filtered curvature for bending fracture$/;"	m	struct:Node	typeref:typename:Mat3x3
d	dde.hpp	/^struct BendingData {double d[3][5];};$/;"	m	struct:BendingData	typeref:typename:double[3][5]
d	dde.hpp	/^struct StretchingData {Vec4 d[2][5];};$/;"	m	struct:StretchingData	typeref:typename:Vec4[2][5]
d	nearobs.cpp	/^    double d;$/;"	m	struct:NearPoint	typeref:typename:double	file:
damage	mesh.hpp	/^    double damage; \/\/ accumulated norm of S_plastic\/S_yield$/;"	m	struct:Face	typeref:typename:double
damage	mesh.hpp	/^    double theta_ideal, damage; \/\/ rest dihedral angle, damage parameter$/;"	m	struct:Edge	typeref:typename:double
damping	cloth.hpp	/^    double damping; \/\/ stiffness-proportional damping coefficient$/;"	m	struct:Material	typeref:typename:double
dde_bending	cloth.hpp	/^    BendingData dde_bending;$/;"	m	struct:Material	typeref:typename:BendingData
dde_stretching	cloth.hpp	/^    StretchingSamples dde_stretching;$/;"	m	struct:Material	typeref:typename:StretchingSamples
deactivate_nodes	mesh.cpp	/^void deactivate_nodes(vector<Node*>& nodes) {$/;"	f	typeref:typename:void
debug	strainlimiting.cpp	/^void debug (const vector<string> &args) {$/;"	f	typeref:typename:void
debug	subset.cpp	/^void MeshSubset::debug() {$/;"	f	class:MeshSubset	typeref:typename:void
debug_color	display.cpp	/^Vec3 debug_color (Face *face, const Vert* vert) {$/;"	f	typeref:typename:Vec3
debug_nodes	taucs.cpp	/^vector<Node*>* debug_nodes = 0;$/;"	v	typeref:typename:vector<Node * > *
debug_save_mesh	util.cpp	/^void debug_save_mesh (const Mesh &mesh, const string &name, int n) {$/;"	f	typeref:typename:void
debug_save_meshes	util.cpp	/^void debug_save_meshes (const vector<Mesh*> &meshvec, const string &name,$/;"	f	typeref:typename:void
debug_save_spmat	sparse.hpp	/^inline void debug_save_spmat (const SpMat<double> &A) {$/;"	f	typeref:typename:void
deep_copy	mesh.cpp	/^Mesh deep_copy (Mesh &mesh0) {$/;"	f	typeref:typename:Mesh
deform_obstacles	collision.cpp	/^static bool deform_obstacles;$/;"	v	typeref:typename:bool	file:
deform_obstacles	separate.cpp	/^static bool deform_obstacles;$/;"	v	typeref:typename:bool	file:
deformation_gradient	physics.cpp	/^Mat3x3 deformation_gradient (const Face *face) {$/;"	f	typeref:typename:Mat3x3
delete_all	remesh.cpp	/^template <class T> static void delete_all(const vector<T>& a) { for(size_t i=0; i<a.size(); i++)/;"	f	typeref:typename:void	file:
delete_constraints	simulation.cpp	/^void delete_constraints (const vector<Constraint*> &cons) {$/;"	f	typeref:typename:void
delete_mesh	mesh.cpp	/^void delete_mesh (Mesh &mesh) {$/;"	f	typeref:typename:void
delete_spaced_out	dynamicremesh.cpp	/^void delete_spaced_out(Mesh& mesh) {$/;"	f	typeref:typename:void
density	cloth.hpp	/^    double density; \/\/ area density$/;"	m	struct:Material	typeref:typename:double
density	simulation.hpp	/^    double density;$/;"	m	struct:Wind	typeref:typename:double
depth	bvh.hpp	/^	FORCEINLINE float depth()  const { return _dist[11] - _dist[2]; }$/;"	f	class:kDOP18	typeref:typename:FORCEINLINE float
derivative	mesh.hpp	/^inline Mat3x3 derivative (const Vec3& w0, const Vec3& w1, $/;"	f	typeref:typename:Mat3x3
derivative	mesh.hpp	/^inline Vec3 derivative (double a0, double a1, double a2, double az, const Face *face) {$/;"	f	typeref:typename:Vec3
destroy_accel_structs	collisionutil.cpp	/^void destroy_accel_structs (vector<AccelStruct*> &accs) {$/;"	f	typeref:typename:void
det	vectors.hpp	/^template <typename T> T det (const Mat<2,2,T> &A) {return A(0,0)*A(1,1) - A(0,1)*A(1,0);}$/;"	f	typeref:typename:T
det	vectors.hpp	/^template <typename T> T det (const Mat<3,3,T> &A) {return stp(A.col(0), A.col(1), A.col(2));}$/;"	f	typeref:typename:T
deterministic_sort	dynamicremesh.cpp	/^} deterministic_sort;$/;"	v	typeref:struct:Deterministic_sort
diag	vectors.hpp	/^template <int n, typename T> MatnnT diag (const VecnT &u) {MatnnT A = MatnnT(0); for (int j = 0;/;"	f	typeref:typename:MatnnT
diag	vectors.hpp	/^template <int n, typename T> VecnT diag (const MatnnT &A) {VecnT u; for (int j = 0; j < n; j++) /;"	f	typeref:typename:VecnT
dihedral_angle	geometry.cpp	/^double dihedral_angle (const Vec3& p0, const Vec3& p1, const Vec3& n0, const Vec3& n1) {$/;"	f	typeref:typename:Vec3 normal Vec3 normal double
dihedral_angle	geometry.cpp	/^template <Space s> double dihedral_angle (const Edge *edge) {$/;"	f	typeref:typename:double
dilate	bvh.cpp	/^BOX dilate (const BOX &box, double d) {$/;"	f	typeref:typename:BOX
dir	display.hpp	/^	Vec3 pos, dir;$/;"	m	struct:Annotation	typeref:typename:Vec3
directional_light	display.cpp	/^void directional_light (int i, const Vec3 &dir, const Vec3 &dif) {$/;"	f	typeref:typename:void
directions	handle.cpp	/^static Vec3 directions[3] = {Vec3(1,0,0), Vec3(0,1,0), Vec3(0,0,1)};$/;"	v	typeref:typename:Vec3[3]	file:
displace_sector	breaking.cpp	/^void displace_sector(Node* node, double disp) {$/;"	f	typeref:typename:void
display_material	display.cpp	/^void display_material () {$/;"	f	typeref:typename:void
display_mode	display.cpp	/^int display_mode = 0;$/;"	v	typeref:typename:int
display_modes	display.cpp	/^DisplayMode display_modes[] = { {"sigma", 1e4, true},$/;"	v	typeref:typename:DisplayMode[]
display_physics	displayphysics.cpp	/^void display_physics (const vector<string> &args) {$/;"	f	typeref:typename:void
display_physics	displayphysics.cpp	/^void display_physics (const vector<string> &args) {opengl_fail();}$/;"	f	typeref:typename:void
display_plastic	display.cpp	/^void display_plastic () {$/;"	f	typeref:typename:void
display_replay	displayreplay.cpp	/^void display_replay (const vector<string> &args) {$/;"	f	typeref:typename:void
display_replay	displayreplay.cpp	/^void display_replay (const vector<string> &args) {opengl_fail();}$/;"	f	typeref:typename:void
display_resume	displayphysics.cpp	/^void display_resume (const vector<string> &args) {$/;"	f	typeref:typename:void
display_resume	displayphysics.cpp	/^void display_resume (const vector<string> &args) {opengl_fail();}$/;"	f	typeref:typename:void
display_testing	displaytesting.cpp	/^void display_testing (const vector<string> &args) {$/;"	f	typeref:typename:void
display_testing	displaytesting.cpp	/^void display_testing (const vector<string> &args) {opengl_fail();}$/;"	f	typeref:typename:void
display_world	display.cpp	/^void display_world () {$/;"	f	typeref:typename:void
distance	physics.cpp	/^double distance (const Vec3 &x, const Vec3 &a, const Vec3 &b) {$/;"	f	typeref:typename:double
done	remesh.cpp	/^void RemeshOp::done () const {$/;"	f	class:RemeshOp	typeref:typename:void
dot	lsnewton.cpp	/^static double dot (const vector<double> &x, const vector<double> &y) {$/;"	f	typeref:typename:double	file:
dot	trustregion.cpp	/^static double dot (const vector<double> &x, const SpMat<double> &A,$/;"	f	typeref:typename:double	file:
dot	trustregion.cpp	/^static double dot (const vector<double> &x, const vector<double> &y) {$/;"	f	typeref:typename:double	file:
dot	vectors.hpp	/^tpl T dot (const VecnT &u, const VecnT &v) {T d = 0; for (int i = 0; i < n; i++) d += u[i]*v[i];/;"	f	typeref:typename:tpl T
down	display.cpp	/^    bool down;$/;"	m	struct:MouseState	typeref:typename:bool	file:
down_x	display.cpp	/^    int down_x, down_y;$/;"	m	struct:MouseState	typeref:typename:int	file:
down_y	display.cpp	/^    int down_x, down_y;$/;"	m	struct:MouseState	typeref:typename:int	file:
drag	simulation.hpp	/^    double drag;$/;"	m	struct:Wind	typeref:typename:double
draw_annotation	display.cpp	/^void draw_annotation(Annotation& a) {$/;"	f	typeref:typename:void
draw_mesh	display.cpp	/^void draw_mesh (const Mesh &mesh, bool set_color=false) {$/;"	f	typeref:typename:void
draw_mesh_ms	display.cpp	/^void draw_mesh_ms (Mesh &mesh, bool set_color=false) {$/;"	f	typeref:typename:void
draw_mesh_ps	display.cpp	/^void draw_mesh_ps (const Mesh &mesh, bool set_color=false) {$/;"	f	typeref:typename:void
draw_meshes	display.cpp	/^void draw_meshes (bool set_color=false) {$/;"	f	typeref:typename:void
draw_meshes_ms	display.cpp	/^void draw_meshes_ms (bool set_color=false) {$/;"	f	typeref:typename:void
draw_meshes_ms_fancy	display.cpp	/^void draw_meshes_ms_fancy () {$/;"	f	typeref:typename:void
draw_meshes_ps	display.cpp	/^void draw_meshes_ps (bool set_color=false) {$/;"	f	typeref:typename:void
draw_node_accels	display.cpp	/^void draw_node_accels () {$/;"	f	typeref:typename:void
draw_node_vels	display.cpp	/^void draw_node_vels () {$/;"	f	typeref:typename:void
draw_seam_or_boundary_edges	display.cpp	/^void draw_seam_or_boundary_edges () {$/;"	f	typeref:typename:void
dsyevc3	vectors.cpp	/^int dsyevc3(const Mat3x3& A, Vec3& w) {$/;"	f	typeref:typename:int
dx0	handle.hpp	/^    Vec3 xc, dx0, dx1;$/;"	m	struct:CircleHandle	typeref:typename:Vec3
dx1	handle.hpp	/^    Vec3 xc, dx0, dx1;$/;"	m	struct:CircleHandle	typeref:typename:Vec3
dynamic_remesh	dynamicremesh.cpp	/^void dynamic_remesh (Mesh& mesh, const map<Node*,Plane> &planes) {$/;"	f	typeref:typename:void
dynamic_remesh	dynamicremesh.cpp	/^void dynamic_remesh (MeshSubset& subset, const map<Node*,Plane> &planes) {$/;"	f	typeref:typename:void
edge	display.hpp	/^	Edge* edge;$/;"	m	struct:Annotation	typeref:typename:Edge *
edge	separate.cpp	/^    Edge *edge[2]; \/\/ edges causing clip$/;"	m	struct:EdgeClipping	typeref:typename:Edge * [2]	file:
edge_box	bvh.cpp	/^BOX edge_box (const Edge *edge, bool ccd) {$/;"	f	typeref:typename:BOX
edge_face_intersection	separate.cpp	/^bool edge_face_intersection (const Edge* edge, const Face *face, Vec3& pt) {$/;"	f	typeref:typename:bool
edge_face_intersection	separate.cpp	/^bool edge_face_intersection (const Vec3& e0, const Vec3& e1,$/;"	f	typeref:typename:bool
edge_flip_threshold	magic.hpp	/^    double edge_flip_threshold;$/;"	m	struct:Magic	typeref:typename:double
edge_metric	dynamicremesh.cpp	/^double edge_metric (const Edge *edge) {$/;"	f	typeref:typename:double
edge_metric	dynamicremesh.cpp	/^double edge_metric (const Vert *vert0, const Vert *vert1) {$/;"	f	typeref:typename:double
edge_node_prox	proximity.cpp	/^static vector< Min<Node*> > edge_node_prox;$/;"	v	typeref:typename:vector<Min<Node * >>	file:
edge_opp_vert	mesh.hpp	/^inline Vert *edge_opp_vert (const Edge *edge, int side) {$/;"	f	typeref:typename:Vert *
edge_plane_intersect	breaking.cpp	/^double edge_plane_intersect(const Vec3& e0, const Vec3& e1, const Vec3& u0, const Vec3& n) {$/;"	f	typeref:typename:double
edge_prox	proximity.cpp	/^static vector< Min<Edge*> > edge_prox[2];$/;"	v	typeref:typename:vector<Min<Edge * >>[2]	file:
edge_vert	mesh.hpp	/^inline Vert *edge_vert (const Edge *edge, int side, int i) {$/;"	f	typeref:typename:Vert *
edges	localopt.cpp	/^    const vector<Edge*>& edges;    $/;"	m	struct:LocalOpt	typeref:typename:const vector<Edge * > &	file:
edges	mesh.hpp	/^    std::vector<Edge*> edges;$/;"	m	struct:Mesh	typeref:typename:std::vector<Edge * >
edges_to_face	plasticity.cpp	/^Mat3x3 edges_to_face (const Vec3 &theta, const Face *face) {$/;"	f	typeref:typename:Mat3x3
ee_clear_distance	separateobs.cpp	/^double ee_clear_distance (const Face *face0, const Face *face1, const Vec3 &d,$/;"	f	namespace:SO	typeref:typename:double
ee_collision_test	collision.cpp	/^bool ee_collision_test (const Edge *edge0, const Edge *edge1, Impact &impact) {$/;"	f	typeref:typename:bool
eigen_decomposition	vectors.cpp	/^template <int n> Eig<n> eigen_decomposition (const Mat<n,n> &A) {$/;"	f	typeref:typename:Eig<n>
eigen_decomposition	vectors.cpp	/^template<> Eig<2> eigen_decomposition<2>(const Mat2x2 &A) {$/;"	f	typeref:typename:Eig<2>
eigen_decomposition	vectors.cpp	/^template<> Eig<3> eigen_decomposition<3>(const Mat3x3 &B) {$/;"	f	typeref:typename:Eig<3>
eigen_values	vectors.cpp	/^template <int n> Vec<n> eigen_values (const Mat<n,n> &A) {$/;"	f	typeref:typename:Vec<n>
eigen_values	vectors.cpp	/^template<> Vec2 eigen_values<2>(const Mat2x2& A) {$/;"	f	typeref:typename:Vec2
eigen_values	vectors.cpp	/^template<> Vec3 eigen_values<3>(const Mat3x3& A) {$/;"	f	typeref:typename:Vec3
embedding_from_plasticity	remesh.cpp	/^void embedding_from_plasticity (const vector<Face*> &fs) {$/;"	f	typeref:typename:void
empty	bvh.hpp	/^	FORCEINLINE void empty() {$/;"	f	class:kDOP18	typeref:typename:FORCEINLINE void
empty	remesh.hpp	/^    bool empty () {return added_faces.empty() && removed_faces.empty();}$/;"	f	struct:RemeshOp	typeref:typename:bool
empty	separate.cpp	/^    bool empty () {return t[0] > t[1];}$/;"	f	struct:EdgeClipping	typeref:typename:bool	file:
enable_localopt	magic.hpp	/^    bool enable_localopt;$/;"	m	struct:Magic	typeref:typename:bool
enabled	display.hpp	/^    bool enabled;$/;"	m	struct:Pane	typeref:typename:bool
enabled	simulation.hpp	/^    bool enabled[nModules];$/;"	m	struct:Simulation	typeref:typename:bool[]
enclosed	tensormax.cpp	/^bool enclosed (const Disk &disk0, const Disk &disk1) {$/;"	f	typeref:typename:bool
end_frame	simulation.hpp	/^    double end_time, end_frame;$/;"	m	struct:Simulation	typeref:typename:double
end_time	handle.hpp	/^    double start_time, end_time, fade_time;$/;"	m	struct:Handle	typeref:typename:double
end_time	obstacle.hpp	/^    double start_time, end_time;$/;"	m	struct:Obstacle	typeref:typename:double
end_time	simulation.hpp	/^    double end_time, end_frame;$/;"	m	struct:Simulation	typeref:typename:double
energy	constraint.cpp	/^double EqCon::energy (double value) {return stiff*sq(value)\/2.;}$/;"	f	class:EqCon	typeref:typename:double
energy	constraint.cpp	/^double GlueCon::energy (double value) {return stiff*sq(value)\/2.;}$/;"	f	class:GlueCon	typeref:typename:double
energy	constraint.cpp	/^double IneqCon::energy (double value) {$/;"	f	class:IneqCon	typeref:typename:double
energy_grad	constraint.cpp	/^double EqCon::energy_grad (double value) {return stiff*value;}$/;"	f	class:EqCon	typeref:typename:double
energy_grad	constraint.cpp	/^double GlueCon::energy_grad (double value) {return stiff*value;}$/;"	f	class:GlueCon	typeref:typename:double
energy_grad	constraint.cpp	/^double IneqCon::energy_grad (double value) {$/;"	f	class:IneqCon	typeref:typename:double
energy_hess	constraint.cpp	/^double EqCon::energy_hess (double value) {return stiff;}$/;"	f	class:EqCon	typeref:typename:double
energy_hess	constraint.cpp	/^double GlueCon::energy_hess (double value) {return stiff;}$/;"	f	class:GlueCon	typeref:typename:double
energy_hess	constraint.cpp	/^double IneqCon::energy_hess (double value) {$/;"	f	class:IneqCon	typeref:typename:double
ensure_existing_directory	io.cpp	/^void ensure_existing_directory (const std::string &path) {$/;"	f	typeref:typename:void
entries	sparse.hpp	/^    std::vector<T> entries;$/;"	m	struct:SpVec	typeref:typename:std::vector<T>
eps_f	optimization.hpp	/^    OptOptions &eps_f (double e) {_eps_f = e; return *this;}$/;"	f	struct:OptOptions	typeref:typename:OptOptions &
eps_f	optimization.hpp	/^    double eps_f () {return _eps_f;}$/;"	f	struct:OptOptions	typeref:typename:double
eps_g	optimization.hpp	/^    OptOptions &eps_g (double e) {_eps_g = e; return *this;}$/;"	f	struct:OptOptions	typeref:typename:OptOptions &
eps_g	optimization.hpp	/^    double eps_g () {return _eps_g;}$/;"	f	struct:OptOptions	typeref:typename:double
eps_x	optimization.hpp	/^    OptOptions &eps_x (double e) {_eps_x = e; return *this;}$/;"	f	struct:OptOptions	typeref:typename:OptOptions &
eps_x	optimization.hpp	/^    double eps_x () {return _eps_x;}$/;"	f	struct:OptOptions	typeref:typename:double
equilibration_step	simulation.cpp	/^void equilibration_step (Simulation &sim) {$/;"	f	typeref:typename:void
error	mot_parser.hpp	/^    std::string error;$/;"	m	class:mot_parser_exception	typeref:typename:std::string
evaluate_stretching_sample	dde.cpp	/^Vec4 evaluate_stretching_sample (const Mat2x2 &_G, const StretchingData &data) {$/;"	f	typeref:typename:Vec4
evaluate_stretching_samples	dde.cpp	/^void evaluate_stretching_samples (StretchingSamples &samples,$/;"	f	typeref:typename:void
exclude	util.hpp	/^template <typename T> inline void exclude (const T &x, std::vector<T> &xs) {$/;"	f	typeref:typename:void
exclude_all	remesh.cpp	/^template <class T> static void exclude_all(const vector<T>& a, vector<T>& b) { for(size_t i=0; i/;"	f	typeref:typename:void	file:
expand_xy	vectors.hpp	/^inline Mat<3,3> expand_xy (const Mat<2,2>& M) { return Mat<3,3> (Vec3(M(0,0),M(0,1),0),Vec3(M(1,/;"	f	typeref:typename:Mat<3,3>
expand_xy	vectors.hpp	/^inline Vec<3> expand_xy(const Vec<2>& v) { return Vec<3>(v[0],v[1],0); }$/;"	f	typeref:typename:Vec<3>
f	constraint.hpp	/^struct MeshGradV { Node* node; Vec3 f; MeshGradV(Node* i, const Vec3& f) : node(i), f(f) {} };$/;"	m	struct:MeshGradV	typeref:typename:Vec3
f	plasticity.cpp	/^    mutable vector<Vec3> f;$/;"	m	struct:EmbedOpt	typeref:typename:vector<Vec3>	file:
f	popfilter.cpp	/^    mutable vector<Vec3> f;$/;"	m	struct:PopOpt	typeref:typename:vector<Vec3>	file:
f0	separate.cpp	/^    Face *f0, *f1;$/;"	m	struct:Ixn	typeref:typename:Face *	file:
f0	separateobs.cpp	/^    Face *f0, *f1;$/;"	m	struct:SO::Ixn	typeref:typename:Face *	file:
f1	separate.cpp	/^    Face *f0, *f1;$/;"	m	struct:Ixn	typeref:typename:Face *	file:
f1	separateobs.cpp	/^    Face *f0, *f1;$/;"	m	struct:SO::Ixn	typeref:typename:Face *	file:
face	display.hpp	/^	Face* face;$/;"	m	struct:Annotation	typeref:typename:Face *
face	sepstrength.cpp	/^	Face* face;$/;"	m	struct:FanPrecomp	typeref:typename:Face *	file:
face_box	bvh.cpp	/^BOX face_box (const Face *face, bool ccd) {$/;"	f	typeref:typename:BOX
face_buffer	bvh.hpp	/^	Face **face_buffer;$/;"	m	class:DeformBVHTree	typeref:typename:Face **
face_plane_intersection	separate.cpp	/^bool face_plane_intersection (const Face *face, const Face *plane,$/;"	f	typeref:typename:bool
face_plane_intersection	separateobs.cpp	/^bool face_plane_intersection (const Face *face, const Face *plane,$/;"	f	namespace:SO	typeref:typename:bool
face_prox	proximity.cpp	/^static vector< Min<Node*> > face_prox[2];$/;"	v	typeref:typename:vector<Min<Node * >>[2]	file:
face_to_edges	plasticity.cpp	/^Vec3 face_to_edges (const Mat3x3 &S, const Face *face) {$/;"	f	typeref:typename:Vec3
faces	localopt.cpp	/^    const vector<Face*>& faces;$/;"	m	struct:LocalOpt	typeref:typename:const vector<Face * > &	file:
faces	mesh.hpp	/^    std::vector<Face*> faces;$/;"	m	struct:Mesh	typeref:typename:std::vector<Face * >
faces	sepstrength.hpp	/^	Face* faces[2];$/;"	m	struct:SplitNode	typeref:typename:Face * [2]
fade_time	handle.hpp	/^    double start_time, end_time, fade_time;$/;"	m	struct:Handle	typeref:typename:double
farthest_points	separateobs.cpp	/^bool farthest_points (const Face *face0, const Face *face1, const Vec3 &d,$/;"	f	namespace:SO	typeref:typename:bool
fill_in_velocity	spline.hpp	/^template <typename T> void fill_in_velocity (Spline<T> &s, int i) {$/;"	f	typeref:typename:void
finalize	collision.cpp	/^void NormalOpt::finalize (const double *x) const {$/;"	f	class:NormalOpt	typeref:typename:void
finalize	localopt.cpp	/^void LocalOpt<s>::finalize (const double *x) const {$/;"	f	class:LocalOpt	typeref:typename:void
finalize	plasticity.cpp	/^void EmbedOpt::finalize (const double *x) const {$/;"	f	class:EmbedOpt	typeref:typename:void
finalize	popfilter.cpp	/^void PopOpt::finalize (const double *x) const {$/;"	f	class:PopOpt	typeref:typename:void
finalize	separateobs.cpp	/^void SeparationOpt::finalize (const double *x) const {$/;"	f	class:SO::SeparationOpt	typeref:typename:void
finalize	strainlimiting.cpp	/^void SLOpt::finalize (const double *x) const {$/;"	f	class:SLOpt	typeref:typename:void
find	bvh.cpp	/^DeformBVHNode::find(Face *face)$/;"	f	class:DeformBVHNode	typeref:typename:bool
find	separate.cpp	/^    size_t find (size_t i) {$/;"	f	struct:UnionFind	typeref:typename:size_t	file:
find	spline.cpp	/^static int find (const Spline<T> &s, double t) {$/;"	f	typeref:typename:int	file:
find	util.hpp	/^template <typename T> inline int find (const T &x, const T *xs, int n=3) {$/;"	f	typeref:typename:int
find	util.hpp	/^template <typename T> inline int find (const T &x, const std::vector<T> &xs) {$/;"	f	typeref:typename:int
find	util.hpp	/^template <typename T> inline int find (const T *x, T* const *xs, int n=3) {$/;"	f	typeref:typename:int
find_bad_edges	dynamicremesh.cpp	/^vector<Edge*> find_bad_edges (const vector<Edge*>& edges) {$/;"	f	typeref:typename:vector<Edge * >
find_edges_to_flip	dynamicremesh.cpp	/^vector<Edge*> find_edges_to_flip (vector<Face*>& active_faces){$/;"	f	typeref:typename:vector<Edge * >
find_face_impacts	collision.cpp	/^void find_face_impacts (const Face *face0, const Face *face1) {$/;"	f	typeref:typename:void
find_face_intersection	separate.cpp	/^void find_face_intersection (const Face *face0, const Face *face1) {$/;"	f	typeref:typename:void
find_face_intersection	separateobs.cpp	/^void find_face_intersection (const Face *face0, const Face *face1) {$/;"	f	namespace:SO	typeref:typename:void
find_face_overlappings	separate.cpp	/^void find_face_overlappings (const Face *face0, const Face *face1) {$/;"	f	typeref:typename:void
find_impacts	collision.cpp	/^vector<Impact> find_impacts (const vector<AccelStruct*> &accs,$/;"	f	typeref:typename:vector<Impact>
find_index	sparse.hpp	/^inline size_t find_index (int i, const std::vector<int> &indices) {$/;"	f	typeref:typename:size_t
find_intersections	separate.cpp	/^vector<Ixn> find_intersections (const vector<AccelStruct*> &accs,$/;"	f	typeref:typename:vector<Ixn>
find_intersections	separateobs.cpp	/^vector<Ixn> find_intersections (const vector<AccelStruct*> &accs,$/;"	f	namespace:SO	typeref:typename:vector<Ixn>
find_or_create_zone	collision.cpp	/^ImpactZone *find_or_create_zone (const Node *node, vector<ImpactZone*> &zones) {$/;"	f	typeref:typename:ImpactZone *
find_overlappings	separate.cpp	/^vector<Ixn> find_overlappings (const vector<AccelStruct*> &accs,$/;"	f	typeref:typename:vector<Ixn>
find_proximities	proximity.cpp	/^void find_proximities (const Face *face0, const Face *face1) {$/;"	f	typeref:typename:void
finite	winport.hpp	/^template <class T> inline bool   finite(const T& number) { return boost::math::isfinite(number);/;"	f	typeref:typename:bool
fix_nonmanifold	breaking.cpp	/^void fix_nonmanifold(Node* node, MeshSubset& subset) {$/;"	f	typeref:typename:void
fixed_high_res_mesh	magic.hpp	/^    bool fixed_high_res_mesh;$/;"	m	struct:Magic	typeref:typename:bool
flag	mesh.hpp	/^    int flag;$/;"	m	struct:Face	typeref:typename:int
flag	mesh.hpp	/^    int flag;$/;"	m	struct:Node	typeref:typename:int
flip_edge	remesh.cpp	/^RemeshOp flip_edge (Edge* edge) {$/;"	f	typeref:typename:RemeshOp
flip_edges	dynamicremesh.cpp	/^void flip_edges (MeshSubset* subset, vector<Face*>& active_faces, $/;"	f	typeref:typename:void
flip_image	io.cpp	/^void flip_image (int w, int h, unsigned char *pixels) {$/;"	f	typeref:typename:void
flip_some_edges	dynamicremesh.cpp	/^bool flip_some_edges (MeshSubset* subset, vector<Face*>& active_faces, $/;"	f	typeref:typename:bool
for_faces_overlapping_obstacles	collisionutil.cpp	/^void for_faces_overlapping_obstacles (const vector<AccelStruct*> &accs,$/;"	f	typeref:typename:void
for_overlapping_faces	collisionutil.cpp	/^void for_overlapping_faces (BVHNode *node, float thickness,$/;"	f	typeref:typename:void
for_overlapping_faces	collisionutil.cpp	/^void for_overlapping_faces (BVHNode *node0, BVHNode *node1, float thickness,$/;"	f	typeref:typename:void
for_overlapping_faces	collisionutil.cpp	/^void for_overlapping_faces (const vector<AccelStruct*> &accs,$/;"	f	typeref:typename:void
fp	util.hpp	/^	gzFile fp;$/;"	m	struct:Serialize	typeref:typename:gzFile
fps	runphysics.cpp	/^Timer fps;$/;"	v	typeref:typename:Timer
fracture	simulation.cpp	/^                 fracture = Simulation::Fracture;$/;"	v	typeref:typename:const int	file:
fracture_bend_thickness	cloth.hpp	/^    double toughness, fracture_bend_thickness; \/\/ fracture toughness$/;"	m	struct:Material	typeref:typename:double
fracture_metric	dynamicremesh.cpp	/^Mat2x2 fracture_metric (Remeshing& remeshing, const Face* face) {$/;"	f	typeref:typename:Mat2x2
frame	runphysics.cpp	/^int frame;$/;"	v	typeref:typename:int
frame	simulation.hpp	/^    int frame, step;$/;"	m	struct:Simulation	typeref:typename:int
frame_steps	simulation.hpp	/^    int frame_steps, save_every;$/;"	m	struct:Simulation	typeref:typename:int
frame_time	simulation.hpp	/^    double frame_time, step_time;$/;"	m	struct:Simulation	typeref:typename:double
frame_x	sepstrength.cpp	/^	Vec3 frame_x, frame_y;$/;"	m	struct:FanPrecomp	typeref:typename:Vec3	file:
frame_y	sepstrength.cpp	/^	Vec3 frame_x, frame_y;$/;"	m	struct:FanPrecomp	typeref:typename:Vec3	file:
frameskip	displayreplay.cpp	/^static int frameskip;$/;"	v	typeref:typename:int	file:
free	constraint.hpp	/^    bool free[4];$/;"	m	struct:IneqCon	typeref:typename:bool[4]
friction	constraint.cpp	/^MeshGrad EqCon::friction (double dt, MeshHess &jac) {return MeshGrad();}$/;"	f	class:EqCon	typeref:typename:MeshGrad
friction	constraint.cpp	/^MeshGrad GlueCon::friction (double dt, MeshHess &jac) {return MeshGrad();}$/;"	f	class:GlueCon	typeref:typename:MeshGrad
friction	constraint.cpp	/^MeshGrad IneqCon::friction (double dt, MeshHess &jac) {$/;"	f	class:IneqCon	typeref:typename:MeshGrad
friction	simulation.hpp	/^    double friction, obs_friction;$/;"	m	struct:Simulation	typeref:typename:double
from_axisangle	transformation.cpp	/^Quaternion Quaternion::from_axisangle(const Vec3 &axis, double angle) {$/;"	f	class:Quaternion	typeref:typename:Quaternion
func	display.cpp	/^    enum {ROTATE, TRANSLATE, SCALE} func;$/;"	m	struct:MouseState	typeref:enum:MouseState::__anonc1288a8c0103	file:
g0	separate.cpp	/^    Vec3 g0[3], g1[3]; \/\/ dl\/dx for each of the faces' nodes$/;"	m	struct:Ixn	typeref:typename:Vec3[3]	file:
g1	separate.cpp	/^    Vec3 g0[3], g1[3]; \/\/ dl\/dx for each of the faces' nodes$/;"	m	struct:Ixn	typeref:typename:Vec3[3]	file:
generate_obj	displayreplay.cpp	/^void generate_obj (const vector<string> &args) {$/;"	f	typeref:typename:void
get	mesh.hpp	/^template <> inline const std::vector<Edge*> &get (const Mesh &mesh) {return mesh.edges;}$/;"	f	typeref:typename:const std::vector<Edge * > &
get	mesh.hpp	/^template <> inline const std::vector<Face*> &get (const Mesh &mesh) {return mesh.faces;}$/;"	f	typeref:typename:const std::vector<Face * > &
get	mesh.hpp	/^template <> inline const std::vector<Node*> &get (const Mesh &mesh) {return mesh.nodes;}$/;"	f	typeref:typename:const std::vector<Node * > &
get	mesh.hpp	/^template <> inline const std::vector<Vert*> &get (const Mesh &mesh) {return mesh.verts;}$/;"	f	typeref:typename:const std::vector<Vert * > &
get	strainlimiting.cpp	/^T* get(int n, const vector<Mesh*>& meshes) {$/;"	f	typeref:typename:T *
getDistances	bvh.hpp	/^	FORCEINLINE static float getDistances(const vec3f &p, int i)$/;"	f	class:kDOP18	typeref:typename:FORCEINLINE float
getDistances	bvh.hpp	/^	FORCEINLINE static void getDistances(const vec3f& p, float d[])$/;"	f	class:kDOP18	typeref:typename:FORCEINLINE void
getDistances	bvh.hpp	/^	FORCEINLINE static void getDistances(const vec3f& p,$/;"	f	class:kDOP18	typeref:typename:FORCEINLINE void
getFace	bvh.hpp	/^	FORCEINLINE Face *getFace() { return _face; }$/;"	f	class:DeformBVHNode	typeref:typename:FORCEINLINE Face *
getLeftChild	bvh.hpp	/^	FORCEINLINE DeformBVHNode *getLeftChild() { return _left; }$/;"	f	class:DeformBVHNode	typeref:typename:FORCEINLINE DeformBVHNode *
getParent	bvh.hpp	/^	FORCEINLINE DeformBVHNode *getParent() { return _parent; }$/;"	f	class:DeformBVHNode	typeref:typename:FORCEINLINE DeformBVHNode *
getRightChild	bvh.hpp	/^	FORCEINLINE DeformBVHNode *getRightChild() { return _right; }$/;"	f	class:DeformBVHNode	typeref:typename:FORCEINLINE DeformBVHNode *
getRoot	bvh.hpp	/^	FORCEINLINE DeformBVHNode *getRoot() { return _root; }$/;"	f	class:DeformBVHTree	typeref:typename:FORCEINLINE DeformBVHNode *
get_all_nodes	subset.cpp	/^vector<Node*> MeshSubset::get_all_nodes() {$/;"	f	class:MeshSubset	typeref:typename:vector<Node * >
get_angle	geometry.cpp	/^double get_angle(const Vec3& u, const Vec3& v) {$/;"	f	typeref:typename:double
get_barycentric_coords	geometry.cpp	/^Vec3 get_barycentric_coords(const Vec2& point, const Face* f) {$/;"	f	typeref:typename:Vec3
get_body_frame	mot_parser.cpp	/^BodyFrame& get_body_frame(BodyVector &bodies, size_t body_index, size_t frame) {$/;"	f	typeref:typename:BodyFrame &
get_body_frames	mot_parser.cpp	/^BodyFrameVector& get_body_frames(BodyVector &bodies, size_t body_index) {$/;"	f	typeref:typename:BodyFrameVector &
get_constraints	handle.cpp	/^vector<Constraint*> CircleHandle::get_constraints (double t) {$/;"	f	class:CircleHandle	typeref:typename:vector<Constraint * >
get_constraints	handle.cpp	/^vector<Constraint*> GlueHandle::get_constraints (double t) {$/;"	f	class:GlueHandle	typeref:typename:vector<Constraint * >
get_constraints	handle.cpp	/^vector<Constraint*> NodeHandle::get_constraints (double t) {$/;"	f	class:NodeHandle	typeref:typename:vector<Constraint * >
get_constraints	handle.cpp	/^vector<Constraint*> SoftHandle::get_constraints (double t) {$/;"	f	class:SoftHandle	typeref:typename:vector<Constraint * >
get_constraints	simulation.cpp	/^vector<Constraint*> get_constraints (Simulation &sim, bool include_proximity) {$/;"	f	typeref:typename:vector<Constraint * >
get_dtrans	transformation.cpp	/^DTransformation get_dtrans (const Motion &motion, double t) {$/;"	f	typeref:typename:DTransformation
get_edge	mesh.hpp	/^inline Edge *get_edge (const Node *n0, const Node *n1) {$/;"	f	typeref:typename:Edge *
get_edges	subset.cpp	/^vector<Edge*> MeshSubset::get_edges() {$/;"	f	class:MeshSubset	typeref:typename:vector<Edge * >
get_enclosing_face	geometry.cpp	/^Face* get_enclosing_face(const Mesh& mesh, const Vec2& u,$/;"	f	typeref:typename:Face *
get_faces	subset.cpp	/^vector<Face*> MeshSubset::get_faces() {$/;"	f	class:MeshSubset	typeref:typename:vector<Face * >
get_line_of_intersection	separate.cpp	/^bool get_line_of_intersection (const Face *face0, const Face *face1, Line3& line) {$/;"	f	typeref:typename:bool
get_mass	collision.cpp	/^static double get_mass (const Node *node) {$/;"	f	typeref:typename:double	file:
get_mass	separate.cpp	/^static double get_mass (const Node *node) {$/;"	f	typeref:typename:double	file:
get_mesh	obstacle.cpp	/^Mesh& Obstacle::get_mesh() {$/;"	f	class:Obstacle	typeref:typename:Mesh &
get_mesh	obstacle.cpp	/^Mesh& Obstacle::get_mesh(double time) {$/;"	f	class:Obstacle	typeref:typename:Mesh &
get_mesh	obstacle.cpp	/^const Mesh& Obstacle::get_mesh() const {$/;"	f	class:Obstacle	typeref:typename:const Mesh &
get_ms_span	sepstrength.cpp	/^static Vec3 get_ms_span (Face* f, Node* center, int offset) {$/;"	f	typeref:typename:Vec3	file:
get_nodes	handle.cpp	/^vector<Node*> SoftHandle::get_nodes() {$/;"	f	class:SoftHandle	typeref:typename:vector<Node * >
get_nodes	handle.hpp	/^    std::vector<Node*> get_nodes () {$/;"	f	struct:GlueHandle	typeref:typename:std::vector<Node * >
get_nodes	handle.hpp	/^    std::vector<Node*> get_nodes () {return std::vector<Node*>();}$/;"	f	struct:CircleHandle	typeref:typename:std::vector<Node * >
get_nodes	handle.hpp	/^    std::vector<Node*> get_nodes () {return std::vector<Node*>(1, node);}$/;"	f	struct:NodeHandle	typeref:typename:std::vector<Node * >
get_outwards_normal	proximity.cpp	/^static inline Vec3 get_outwards_normal(const Edge *e) {$/;"	f	typeref:typename:Vec3	file:
get_positive	vectors.cpp	/^template <int n> Mat<n,n> get_positive (const Mat<n,n> &A) {$/;"	f	typeref:typename:Mat<n,n>
get_strain_limits	strainlimiting.cpp	/^vector<StrainLimit> get_strain_limits (const vector<Cloth> &cloths) {$/;"	f	typeref:typename:vector<StrainLimit>
get_submat	optimization.hpp	/^inline Mat3x3 get_submat (SpMat<double> &A, int i, int j) {$/;"	f	typeref:typename:Mat3x3
get_subvec	optimization.hpp	/^inline Vec3 get_subvec (const double *x, int i) {$/;"	f	typeref:typename:Vec3
get_subvec	optimization.hpp	/^template <int n> Vec<n> get_subvec (const double *x, int i) {$/;"	f	typeref:typename:Vec<n>
get_trans	transformation.cpp	/^Transformation get_trans (const Motion &motion, double t) {$/;"	f	typeref:typename:Transformation
get_valid_line	io.cpp	/^void get_valid_line (istream &in, string &line) {$/;"	f	typeref:typename:void
get_vert	mesh.hpp	/^inline Vert* get_vert (const Face* face, const Node* node) {$/;"	f	typeref:typename:Vert *
get_verts	subset.cpp	/^vector<Vert*> MeshSubset::get_verts() {$/;"	f	class:MeshSubset	typeref:typename:vector<Vert * >
gradient	constraint.cpp	/^MeshGrad EqCon::gradient () {MeshGrad grad; grad.push_back(MeshGradV(node,n)); return grad;}$/;"	f	class:EqCon	typeref:typename:MeshGrad
gradient	constraint.cpp	/^MeshGrad GlueCon::gradient () {$/;"	f	class:GlueCon	typeref:typename:MeshGrad
gradient	constraint.cpp	/^MeshGrad IneqCon::gradient () {$/;"	f	class:IneqCon	typeref:typename:MeshGrad
gradient	localopt.cpp	/^void LocalOpt<s>::gradient (const double *x, double *g) const {$/;"	f	class:LocalOpt	typeref:typename:void
gradient	plasticity.cpp	/^void EmbedOpt::gradient (const double *x, double *g) const {$/;"	f	class:EmbedOpt	typeref:typename:void
gradient	popfilter.cpp	/^void PopOpt::gradient (const double *x, double *g) const {$/;"	f	class:PopOpt	typeref:typename:void
gravity	simulation.hpp	/^    Vec3 gravity;$/;"	m	struct:Simulation	typeref:typename:Vec3
grow	subset.cpp	/^void MeshSubset::grow(int rings) {$/;"	f	class:MeshSubset	typeref:typename:void
handle_stiffness	magic.hpp	/^    double handle_stiffness, collision_stiffness;$/;"	m	struct:Magic	typeref:typename:double
handles	simulation.hpp	/^    std::vector<Handle*> handles;$/;"	m	struct:Simulation	typeref:typename:std::vector<Handle * >
has_labeled_edges	dynamicremesh.cpp	/^bool has_labeled_edges (const Node *node) {$/;"	f	typeref:typename:bool
has_node	proximity.cpp	/^static inline bool has_node(const Face* f, const Node* n) {$/;"	f	typeref:typename:bool	file:
head	tensormax.cpp	/^template <typename T> T head (const vector<T> &v) {$/;"	f	typeref:typename:T
height	bvh.hpp	/^	FORCEINLINE float height() const { return _dist[10] - _dist[1]; }$/;"	f	class:kDOP18	typeref:typename:FORCEINLINE float
hessian	localopt.cpp	/^bool LocalOpt<s>::hessian (const double *x, SpMat<double> &H) const {$/;"	f	class:LocalOpt	typeref:typename:bool
hessian	optimization.hpp	/^    virtual bool hessian (const double *x, SpMat<double> &H) const {$/;"	f	struct:NLOpt	typeref:typename:bool
hessian	plasticity.cpp	/^bool EmbedOpt::hessian (const double *x, SpMat<double> &H) const {$/;"	f	class:EmbedOpt	typeref:typename:bool
hessian	popfilter.cpp	/^bool PopOpt::hessian (const double *x, SpMat<double> &H) const {$/;"	f	class:PopOpt	typeref:typename:bool
i	constraint.hpp	/^struct MeshHessV { Node* i; Node* j; Mat3x3 J; MeshHessV(Node *i, Node* j, const Mat3x3& J) : i(/;"	m	struct:MeshHessV	typeref:typename:Node *
identity	transformation.cpp	/^Transformation identity () {$/;"	f	typeref:typename:Transformation
idle	display.hpp	/^    void (*idle) ();$/;"	m	struct:GlutCallbacks	typeref:typename:void (*)()
idle	displayphysics.cpp	/^static void idle () {$/;"	f	typeref:typename:void	file:
idle	displayreplay.cpp	/^static void idle () {$/;"	f	typeref:typename:void	file:
impacts	collision.cpp	/^    vector<Impact> impacts;$/;"	m	struct:ImpactZone	typeref:typename:vector<Impact>	file:
impacts	collision.cpp	/^static vector<Impact> *impacts = NULL;$/;"	v	typeref:typename:vector<Impact> *	file:
implicit_update	physics.cpp	/^vector<Vec3> implicit_update (vector<Node*>& nodes, const vector<Edge*>& edges, const vector<Fac/;"	f	typeref:typename:vector<Vec3>
improve_some_face	dynamicremesh.cpp	/^bool improve_some_face (MeshSubset* subset, vector<Face*>& active) {$/;"	f	typeref:typename:bool
in_wedge	proximity.cpp	/^bool in_wedge (double w, const Edge *edge0, const Edge *edge1) {$/;"	f	typeref:typename:bool
include	util.hpp	/^template <typename T> inline void include (const T &x, std::vector<T> &xs) {$/;"	f	typeref:typename:void
include_all	remesh.cpp	/^template <class T> static void include_all(const vector<T>& a, vector<T>& b) { for(size_t i=0; i/;"	f	typeref:typename:void	file:
independent	dynamicremesh.cpp	/^bool independent (const Edge *edge, const vector<Edge*> &edges) {$/;"	f	typeref:typename:bool
independent_edges	dynamicremesh.cpp	/^vector<Edge*> independent_edges (const vector<Edge*> &edges) {$/;"	f	typeref:typename:vector<Edge * >
independent_impacts	collision.cpp	/^vector<Impact> independent_impacts (const vector<Impact> &impacts) {$/;"	f	typeref:typename:vector<Impact>
index	mesh.hpp	/^    int index; \/\/ position in mesh.edges$/;"	m	struct:Edge	typeref:typename:int
index	mesh.hpp	/^    int index; \/\/ position in mesh.faces$/;"	m	struct:Face	typeref:typename:int
index	mesh.hpp	/^    int index; \/\/ position in mesh.nodes$/;"	m	struct:Node	typeref:typename:int
index	mesh.hpp	/^    int index; \/\/ position in mesh.verts$/;"	m	struct:Vert	typeref:typename:int
indices	physics.cpp	/^Vec<3,int> indices (const Node *n0, const Node *n1, const Node *n2) {$/;"	f	typeref:typename:Vec<3,int>
indices	physics.cpp	/^Vec<4,int> indices (const Node *n0, const Node *n1,$/;"	f	typeref:typename:Vec<4,int>
indices	sparse.hpp	/^    std::vector<int> indices;$/;"	m	struct:SpVec	typeref:typename:std::vector<int>
infinity	util.cpp	/^const double infinity = numeric_limits<double>::infinity();$/;"	v	typeref:typename:const double
init_glut	display.cpp	/^void init_glut (const GlutCallbacks &cb) {$/;"	f	typeref:typename:void
init_physics	runphysics.cpp	/^void init_physics (const string &json_file, string outprefix,$/;"	f	typeref:typename:void
init_relax	runphysics.cpp	/^void init_relax() {$/;"	f	typeref:typename:void
init_resume	runphysics.cpp	/^void init_resume(const vector<string> &args) {$/;"	f	typeref:typename:void
init_view	display.cpp	/^void init_view(Pane& view) {$/;"	f	typeref:typename:void
initialize	collision.cpp	/^void NormalOpt::initialize (double *x) const {$/;"	f	class:NormalOpt	typeref:typename:void
initialize	localopt.cpp	/^void LocalOpt<s>::initialize (double *x) const {$/;"	f	class:LocalOpt	typeref:typename:void
initialize	plasticity.cpp	/^void EmbedOpt::initialize (double *x) const {$/;"	f	class:EmbedOpt	typeref:typename:void
initialize	popfilter.cpp	/^void PopOpt::initialize (double *x) const {$/;"	f	class:PopOpt	typeref:typename:void
initialize	separateobs.cpp	/^void SeparationOpt::initialize (double *x) const {$/;"	f	class:SO::SeparationOpt	typeref:typename:void
initialize	strainlimiting.cpp	/^void SLOpt::initialize (double *x) const {$/;"	f	class:SLOpt	typeref:typename:void
initialized	display.hpp	/^    bool initialized;$/;"	m	struct:Pane	typeref:typename:bool
inner	vectors.hpp	/^tpl T inner (const MatmnT &a, const MatmnT& b) { T r=0; for (int j=0; j<n; j++) for (int i=0; i</;"	f	typeref:typename:tpl T
inprefix	runphysics.cpp	/^string inprefix, outprefix;$/;"	v	typeref:typename:string
insert_index	sparse.hpp	/^template <typename T> void insert_index (int i, int j,$/;"	f	typeref:typename:void
inside	bvh.cpp	/^	FORCEINLINE bool inside(const vec3f &mid) const {$/;"	f	class:aap	typeref:typename:FORCEINLINE bool	file:
inside	bvh.hpp	/^	FORCEINLINE bool inside(const vec3f &p) const$/;"	f	class:kDOP18	typeref:typename:FORCEINLINE bool
internal_energy	physics.cpp	/^double internal_energy (const vector<Face*>& faces, const vector<Edge*>& edges) {$/;"	f	typeref:typename:double
intersection_midpoint	separate.cpp	/^bool intersection_midpoint (const Face *face0, const Face *face1,$/;"	f	typeref:typename:bool
intersection_midpoint	separateobs.cpp	/^bool intersection_midpoint (const Face *face0, const Face *face1,$/;"	f	namespace:SO	typeref:typename:bool
inv	vectors.hpp	/^    MatmnT inv () const {return inverse(*this);}$/;"	f	class:Mat	typeref:typename:MatmnT
invDm	mesh.hpp	/^    Mat3x3 Dm, invDm; \/\/ finite element matrix$/;"	m	struct:Face	typeref:typename:Mat3x3
inv_m	collision.cpp	/^    double inv_m;$/;"	m	struct:NormalOpt	typeref:typename:double	file:
inv_m	separateobs.cpp	/^    double inv_m;$/;"	m	struct:SO::SeparationOpt	typeref:typename:double	file:
inv_m	strainlimiting.cpp	/^    double inv_m;$/;"	m	struct:SLOpt	typeref:typename:double	file:
inverse	remesh.cpp	/^RemeshOp RemeshOp::inverse () const {$/;"	f	class:RemeshOp	typeref:typename:RemeshOp
inverse	transformation.cpp	/^Quaternion inverse(const Quaternion &q) {$/;"	f	typeref:typename:Quaternion
inverse	transformation.cpp	/^Transformation inverse(const Transformation &tr) {$/;"	f	typeref:typename:Transformation
inverse	vectors.hpp	/^template <typename T> Mat<2,2,T> inverse (const Mat<2,2,T> &A) {return Mat<2,2,T>(Vec<2,T>(A(1,1/;"	f	typeref:typename:Mat<2,2,T>
inverse	vectors.hpp	/^template <typename T> Mat<3,3,T> inverse (const Mat<3,3,T> &A) {return Mat<3,3,T>(cross(A.col(1)/;"	f	typeref:typename:Mat<3,3,T>
isLeaf	bvh.hpp	/^	FORCEINLINE bool isLeaf() { return _left == NULL; }$/;"	f	class:DeformBVHNode	typeref:typename:FORCEINLINE bool
isRoot	bvh.hpp	/^	FORCEINLINE bool isRoot() { return _parent == NULL;}$/;"	f	class:DeformBVHNode	typeref:typename:FORCEINLINE bool
is_all_whitespace	mot_parser.cpp	/^bool is_all_whitespace(const string& empty) {$/;"	f	typeref:typename:bool
is_bullshit	vectors.hpp	/^tpl inline bool is_bullshit(const VecnT& v) { for (int i=0; i<n; i++) { if (v[i] > 1e100 || v[i]/;"	f	typeref:typename:tpl bool
is_finite	util.hpp	/^inline bool is_finite(double x) { return x > -1e300 && x < 1e300; }$/;"	f	typeref:typename:bool
is_free	collisionutil.hpp	/^template<> inline bool is_free<Edge> (const Edge* p) { return p->n[0]->verts[0]->adjf[0]->materi/;"	f	typeref:typename:bool
is_free	collisionutil.hpp	/^template<> inline bool is_free<Face> (const Face* p) { return p->material; }$/;"	f	typeref:typename:bool
is_free	collisionutil.hpp	/^template<> inline bool is_free<Node> (const Node* p) { return p->verts[0]->adjf[0]->material; }$/;"	f	typeref:typename:bool
is_free	collisionutil.hpp	/^template<> inline bool is_free<Vert> (const Vert* p) { return p->adjf[0]->material; }$/;"	f	typeref:typename:bool
is_in	util.hpp	/^template <typename T> inline bool is_in (const T &x, const T *xs, int n=3) {$/;"	f	typeref:typename:bool
is_in	util.hpp	/^template <typename T> inline bool is_in (const T &x, const std::vector<T> &xs) {$/;"	f	typeref:typename:bool
is_in	util.hpp	/^template <typename T> inline bool is_in (const T *x, T* const *xs, int n=3) {$/;"	f	typeref:typename:bool
is_inside	geometry.cpp	/^bool is_inside(const Vec2& point, const Face* f) {$/;"	f	typeref:typename:bool
is_seam	util.cpp	/^bool is_seam (const Edge* e) {$/;"	f	typeref:typename:bool
is_seam_or_boundary	util.cpp	/^bool is_seam_or_boundary (const Edge *e) {$/;"	f	typeref:typename:bool
is_seam_or_boundary	util.cpp	/^bool is_seam_or_boundary (const Face *f) {$/;"	f	typeref:typename:bool
is_seam_or_boundary	util.cpp	/^bool is_seam_or_boundary (const Node *n) {$/;"	f	typeref:typename:bool
is_seam_or_boundary	util.cpp	/^bool is_seam_or_boundary (const Vert *v) {$/;"	f	typeref:typename:bool
isfinite	winport.hpp	/^template <class T> inline bool isfinite(const T& number) { return boost::math::isfinite(number);/;"	f	typeref:typename:bool
ixns	separate.cpp	/^static vector<Ixn> *ixns = NULL;$/;"	v	typeref:typename:vector<Ixn> *	file:
ixns	separateobs.cpp	/^    const vector<Ixn> &ixns;$/;"	m	struct:SO::SeparationOpt	typeref:typename:const vector<Ixn> &	file:
ixns	separateobs.cpp	/^static vector<Ixn> *ixns = NULL;$/;"	v	namespace:SO	typeref:typename:vector<Ixn> *	file:
j	constraint.hpp	/^struct MeshHessV { Node* i; Node* j; Mat3x3 J; MeshHessV(Node *i, Node* j, const Mat3x3& J) : i(/;"	m	struct:MeshHessV	typeref:typename:Node *
kDOP18	bvh.hpp	/^	FORCEINLINE kDOP18() {$/;"	f	class:kDOP18	typeref:typename:FORCEINLINE
kDOP18	bvh.hpp	/^	FORCEINLINE kDOP18(const vec3f &a, const vec3f &b) {$/;"	f	class:kDOP18	typeref:typename:FORCEINLINE
kDOP18	bvh.hpp	/^	FORCEINLINE kDOP18(const vec3f &v) {$/;"	f	class:kDOP18	typeref:typename:FORCEINLINE
kDOP18	bvh.hpp	/^class kDOP18 {$/;"	c
key	nearobs.cpp	/^    double key;$/;"	m	struct:Min	typeref:typename:double	file:
key	proximity.cpp	/^    double key;$/;"	m	struct:Min	typeref:typename:double	file:
keyboard	display.hpp	/^    void (*keyboard) (unsigned char, int, int);$/;"	m	struct:GlutCallbacks	typeref:typename:void (*)(unsigned char,int,int)
keyboard	displayphysics.cpp	/^static void keyboard (unsigned char key, int x, int y) {$/;"	f	typeref:typename:void	file:
keyboard	displayreplay.cpp	/^static void keyboard (unsigned char key, int x, int y) {$/;"	f	typeref:typename:void	file:
keyboard	displaytesting.cpp	/^static void keyboard (unsigned char key, int x, int y) {$/;"	f	typeref:typename:void	file:
keyboard_handler	display.cpp	/^void keyboard_handler(unsigned char key, int x, int y) {$/;"	f	typeref:typename:void
keyboard_sub	display.cpp	/^void (*keyboard_sub)(unsigned char, int, int);$/;"	v	typeref:typename:void (*)(unsigned char,int,int)
kronecker	physics.cpp	/^Mat<m*p,n*q> kronecker (const Mat<m,n> &A, const Mat<p,q> &B) {$/;"	f	typeref:typename:Mat<m * p,n * q>
l	separate.cpp	/^    double l;$/;"	m	struct:Ixn	typeref:typename:double	file:
l	vectors.hpp	/^    Vec<n> l;$/;"	m	struct:Eig	typeref:typename:Vec<n>
l_bfgs_method	lbfgs.cpp	/^void l_bfgs_method (const NLOpt &problem, OptOptions opt, bool verbose) {$/;"	f	typeref:typename:void
label	handle.hpp	/^    int label;$/;"	m	struct:CircleHandle	typeref:typename:int
label	mesh.hpp	/^    int label;$/;"	m	struct:Node	typeref:typename:int
lambda	auglag.cpp	/^static vector<double> lambda;$/;"	v	typeref:typename:vector<double>	file:
lapack_int	vectors.cpp	/^#define lapack_int /;"	d	file:
last	timer.hpp	/^    double last, total;$/;"	m	struct:Timer	typeref:typename:double
lat	display.hpp	/^	double lat, lon;$/;"	m	struct:Pane	typeref:typename:double
lbfgs_value_and_grad	lbfgs.cpp	/^static void lbfgs_value_and_grad (const real_1d_array &x, double &value,$/;"	f	typeref:typename:void	file:
leaves	collisionutil.hpp	/^    std::map<const Face*, BVHNode*> leaves;$/;"	m	struct:AccelStruct	typeref:typename:std::map<const Face *,BVHNode * >
length	bvh.hpp	/^	FORCEINLINE float length(int i) const {$/;"	f	class:kDOP18	typeref:typename:FORCEINLINE float
line_circle_intersection	trustregion.cpp	/^double line_circle_intersection (double n1, double n2, double d, double r) {$/;"	f	typeref:typename:double
line_search	lsnewton.cpp	/^double line_search (const vector<double> &x0, const vector<double> &p,$/;"	f	typeref:typename:double
line_search_newtons_method	lsnewton.cpp	/^void line_search_newtons_method (const NLOpt &problem, OptOptions opt,$/;"	f	typeref:typename:void
list	display.cpp	/^vector<Annotation> Annotation::list;$/;"	m	class:Annotation	typeref:typename:vector<Annotation>
list	display.hpp	/^	static std::vector<Annotation> list;$/;"	m	struct:Annotation	typeref:typename:std::vector<Annotation>
load	util.hpp	/^	bool load() { return mode == Load; }$/;"	f	struct:Serialize	typeref:typename:bool
load_json	conf.cpp	/^void load_json (const string &configFilename, Simulation &sim) {$/;"	f	typeref:typename:void
load_material_data	conf.cpp	/^void load_material_data (Material &material, const string &filename) {$/;"	f	typeref:typename:void
load_mot	mot_parser.cpp	/^std::vector<Motion> load_mot (const std::string &filename, double fps) {$/;"	f	typeref:typename:std::vector<Motion>
load_obj	io.cpp	/^void load_obj (Mesh &mesh, const string &filename) {$/;"	f	typeref:typename:void
load_objs	io.cpp	/^void load_objs (vector<Mesh*> &meshes, const string &prefix) {$/;"	f	typeref:typename:void
load_state	io.cpp	/^bool load_state (T& state, const string &prefix) {$/;"	f	typeref:typename:bool
local_base	geometry.cpp	/^Mat3x3 local_base(const Vec3& normal) {$/;"	f	typeref:typename:Mat3x3
local_opt	localopt.cpp	/^void local_opt(vector<Node*>& nodes, vector<Face*>& faces, vector<Edge*>& edges,$/;"	f	typeref:typename:void
local_physics_step	breaking.cpp	/^void local_physics_step(MeshSubset& subset) {$/;"	f	typeref:typename:void
local_pop_filter	remesh.cpp	/^void local_pop_filter (const vector<Face*> &fs) {$/;"	f	typeref:typename:void
log2	winport.hpp	/^template <class T> inline T log2(const T& number) { return log(number)\/log(T(2)); }$/;"	f	typeref:typename:T
log_stiffness	morph.hpp	/^    Spline<double> log_stiffness;$/;"	m	struct:Morph	typeref:typename:Spline<double>
lon	display.hpp	/^	double lat, lon;$/;"	m	struct:Pane	typeref:typename:double
m	mesh.hpp	/^    double a, m; \/\/ area, mass$/;"	m	struct:Face	typeref:typename:double
m	mesh.hpp	/^    double a, m; \/\/ area, mass$/;"	m	struct:Node	typeref:typename:double
m	sparse.hpp	/^    int m, n;$/;"	m	struct:SpMat	typeref:typename:int
magic	magic.cpp	/^Magic magic;$/;"	v	typeref:typename:Magic
main	main.cpp	/^int main (int argc, char **argv) {$/;"	f	typeref:typename:int
major_axis	separate.cpp	/^int major_axis (const Vec3 &v) {$/;"	f	typeref:typename:int
major_axis	separateobs.cpp	/^int major_axis (const Vec3 &v) {$/;"	f	namespace:SO	typeref:typename:int
make_constraint	proximity.cpp	/^Constraint *make_constraint (const Edge *edge0, const Edge *edge1,$/;"	f	typeref:typename:Constraint *
make_constraint	proximity.cpp	/^Constraint *make_constraint (const Edge* edge, const Node* node, double mu, double mu_obs) {$/;"	f	typeref:typename:Constraint *
make_constraint	proximity.cpp	/^Constraint *make_constraint (const Node *node, const Face *face,$/;"	f	typeref:typename:Constraint *
make_proxy_constraints	proximity.cpp	/^void make_proxy_constraints (Mesh& mesh, CollisionProxy& proxy, vector<Constraint*>& cons) {$/;"	f	typeref:typename:void
malloc_align	vectors.hpp	/^inline void* malloc_align(size_t size, size_t alignment = 32) { return _aligned_malloc(size, ali/;"	f	typeref:typename:void *
malloc_align	vectors.hpp	/^inline void* malloc_align(size_t size, size_t alignment = 32) {$/;"	f	typeref:typename:void *
mark_active	collisionutil.cpp	/^void mark_active (AccelStruct &acc, const Face *face) {$/;"	f	typeref:typename:void
mark_all_inactive	collisionutil.cpp	/^void mark_all_inactive (AccelStruct &acc) {$/;"	f	typeref:typename:void
mark_ancestors	collisionutil.cpp	/^void mark_ancestors (BVHNode *node, bool active) {$/;"	f	typeref:typename:void
mark_descendants	collisionutil.cpp	/^void mark_descendants (BVHNode *node, bool active) {$/;"	f	typeref:typename:void
mark_nodes_to_preserve	mesh.cpp	/^void mark_nodes_to_preserve (Mesh &mesh) {$/;"	f	typeref:typename:void
mat_to_vec	blockvectors.hpp	/^Vec<m*n,T> mat_to_vec (const Mat<m,n,T> &A) {$/;"	f	typeref:typename:Vec<m * n,T>
material	display.hpp	/^    static Pane& material() { return panes[0]; }$/;"	f	struct:Pane	typeref:typename:Pane &
material	mesh.hpp	/^    Material* material;$/;"	m	struct:Face	typeref:typename:Material *
material_model	physics.cpp	/^Mat3x3 material_model (const Face *face, const Mat3x3& G) {$/;"	f	typeref:typename:Mat3x3
materials	cloth.hpp	/^    std::vector<Material*> materials;    $/;"	m	struct:Cloth	typeref:typename:std::vector<Material * >
matrix_mag	display.cpp	/^inline double matrix_mag(const Mat3x3& M) {$/;"	f	typeref:typename:double
max	conf.cpp	/^    double &min, &max;$/;"	m	struct:Range	typeref:typename:double &	file:
max	strainlimiting.hpp	/^    double min, max;$/;"	m	struct:StrainLimit	typeref:typename:double
max	util.cpp	/^double Stats::max () const {sort(); return xs.back();}$/;"	f	class:Stats	typeref:typename:double
max	util.hpp	/^template <typename T> T max (const T &a, const T &b, const T &c) {$/;"	f	typeref:typename:T
max	util.hpp	/^template <typename T> T max (const T &a, const T &b, const T &c, const T &d) {$/;"	f	typeref:typename:T
max	vectors.hpp	/^tpl MatmnT max (const MatmnT& a, const MatmnT& b) { MatmnT c; for (int i = 0; i < m; i++) for (i/;"	f	typeref:typename:tpl MatmnT
max_cracks	magic.hpp	/^    int relax_method, max_cracks;$/;"	m	struct:Magic	typeref:typename:int
max_iter	collision.cpp	/^static const int max_iter = 30;$/;"	v	typeref:typename:const int	file:
max_iter	optimization.hpp	/^    OptOptions &max_iter (int n) {_max_iter = n; return *this;}$/;"	f	struct:OptOptions	typeref:typename:OptOptions &
max_iter	optimization.hpp	/^    int max_iter () {return _max_iter;}$/;"	f	struct:OptOptions	typeref:typename:int
max_iter	separateobs.cpp	/^static const int max_iter = 100;$/;"	v	namespace:SO	typeref:typename:const int	file:
mean	util.cpp	/^double Stats::mean () const {return sum\/xs.size();}$/;"	f	class:Stats	typeref:typename:double
median	util.cpp	/^double Stats::median () const {return quantile(0.5);}$/;"	f	class:Stats	typeref:typename:double
merge_meshes	misc.cpp	/^void merge_meshes (const vector<string> &args) {$/;"	f	typeref:typename:void
merge_zones	collision.cpp	/^void merge_zones (ImpactZone* zone0, ImpactZone *zone1,$/;"	f	typeref:typename:void
mesh	cloth.hpp	/^    Mesh mesh;$/;"	m	struct:Cloth	typeref:typename:Mesh
mesh	handle.hpp	/^    Mesh *mesh;$/;"	m	struct:CircleHandle	typeref:typename:Mesh *
mesh	handle.hpp	/^    Mesh *mesh;$/;"	m	struct:SoftHandle	typeref:typename:Mesh *
mesh	mesh.hpp	/^	Mesh* mesh;$/;"	m	struct:Node	typeref:typename:Mesh *
mesh	morph.hpp	/^    Mesh *mesh;$/;"	m	struct:Morph	typeref:typename:Mesh *
mesh	plasticity.cpp	/^    Mesh &mesh;$/;"	m	struct:EmbedOpt	typeref:typename:Mesh &	file:
mesh	popfilter.cpp	/^    Mesh &mesh;$/;"	m	struct:PopOpt	typeref:typename:Mesh &	file:
meshes	collisionutil.cpp	/^const vector<Mesh*> *meshes, *obs_meshes;$/;"	v	typeref:typename:const vector<Mesh * > *
meshes	strainlimiting.cpp	/^    vector<Mesh*> meshes;$/;"	m	struct:SLOpt	typeref:typename:vector<Mesh * >	file:
middle_xyz	bvh.cpp	/^inline float middle_xyz(char xyz, const vec3f &p1, const vec3f &p2, const vec3f &p3)$/;"	f	typeref:typename:float
min	conf.cpp	/^    double &min, &max;$/;"	m	struct:Range	typeref:typename:double &	file:
min	strainlimiting.hpp	/^    double min, max;$/;"	m	struct:StrainLimit	typeref:typename:double
min	util.cpp	/^double Stats::min () const {sort(); return xs.front();}$/;"	f	class:Stats	typeref:typename:double
min	util.hpp	/^template <typename T> T min (const T &a, const T &b, const T &c) {$/;"	f	typeref:typename:T
min	util.hpp	/^template <typename T> T min (const T &a, const T &b, const T &c, const T &d) {$/;"	f	typeref:typename:T
minidisk	tensormax.cpp	/^Disk minidisk (const vector<Disk> &P) {$/;"	f	typeref:typename:Disk
minimize_in_ball	trustregion.cpp	/^bool minimize_in_ball (const vector<double> &g, const SpMat<double> &H,$/;"	f	typeref:typename:bool
mode	util.hpp	/^	Mode mode;$/;"	m	struct:Serialize	typeref:typename:Mode
morphs	simulation.hpp	/^    std::vector<Morph> morphs;$/;"	m	struct:Simulation	typeref:typename:std::vector<Morph>
mot_parser_exception	mot_parser.hpp	/^    mot_parser_exception(const std::string& error) : error(error) {}$/;"	f	class:mot_parser_exception
mot_parser_exception	mot_parser.hpp	/^class mot_parser_exception {$/;"	c
mot_to_spline	mot_parser.cpp	/^vector<Spline<Transformation> > mot_to_spline(string motion_file, const Transformation& tr,$/;"	f	typeref:typename:vector<Spline<Transformation>>
mot_to_transforms	mot_parser.cpp	/^vector<vector<Transformation> > mot_to_transforms(string motion_file) {$/;"	f	typeref:typename:vector<vector<Transformation>>
motion	display.cpp	/^void motion (int x, int y) {$/;"	f	typeref:typename:void
motion	handle.hpp	/^    const Motion *motion;$/;"	m	struct:CircleHandle	typeref:typename:const Motion *
motion	handle.hpp	/^    const Motion *motion;$/;"	m	struct:NodeHandle	typeref:typename:const Motion *
motion	handle.hpp	/^    const Motion *motion;$/;"	m	struct:SoftHandle	typeref:typename:const Motion *
motions	simulation.hpp	/^    std::vector<Motion> motions;$/;"	m	struct:Simulation	typeref:typename:std::vector<Motion>
mouse	display.cpp	/^void mouse (int button, int state, int x, int y) {$/;"	f	typeref:typename:void
mouse_state	display.cpp	/^} mouse_state;$/;"	v	typeref:struct:MouseState
mu	auglag.cpp	/^static double mu;$/;"	v	typeref:typename:double	file:
mu	constraint.hpp	/^    double mu; \/\/ friction$/;"	m	struct:IneqCon	typeref:typename:double
mu	plasticity.cpp	/^static const double mu = 1e-6;$/;"	v	typeref:typename:const double	file:
mu	popfilter.cpp	/^static double mu;$/;"	v	typeref:typename:double	file:
multiplier_update	auglag.cpp	/^static void multiplier_update (const real_1d_array &x) {$/;"	f	typeref:typename:void	file:
n	collision.cpp	/^    Vec3 n;$/;"	m	struct:Impact	typeref:typename:Vec3	file:
n	constraint.hpp	/^    Vec3 n;$/;"	m	struct:GlueCon	typeref:typename:Vec3
n	constraint.hpp	/^    Vec3 n;$/;"	m	struct:IneqCon	typeref:typename:Vec3
n	constraint.hpp	/^    Vec3 x, n;$/;"	m	struct:EqCon	typeref:typename:Vec3
n	mesh.hpp	/^    Node *n[2]; \/\/ nodes$/;"	m	struct:Edge	typeref:typename:Node * [2]
n	mesh.hpp	/^    Vec3 n; \/\/ local normal, approximate$/;"	m	struct:Node	typeref:typename:Vec3
n	mesh.hpp	/^    Vec3 n; \/\/ local normal, exact$/;"	m	struct:Face	typeref:typename:Vec3
n	mesh.hpp	/^    Vec3 x0, n;$/;"	m	struct:Plane	typeref:typename:Vec3
n	separateobs.cpp	/^    Vec3 n;$/;"	m	struct:SO::Ixn	typeref:typename:Vec3	file:
n	sparse.hpp	/^    int m, n;$/;"	m	struct:SpMat	typeref:typename:int
nModules	simulation.hpp	/^          PopFilter, Plasticity, Fracture, nModules};$/;"	e	enum:Simulation::__anon8619f0600103
name	display.cpp	/^struct DisplayMode { string name; double scale; bool active; };$/;"	m	struct:DisplayMode	typeref:typename:string	file:
name	main.cpp	/^        string name;$/;"	m	struct:main::Action	typeref:typename:string	file:
name	util.cpp	/^template <typename T> string name (const T *p) {$/;"	f	typeref:typename:string
ncon	optimization.hpp	/^    int nvar, ncon;$/;"	m	struct:NLConOpt	typeref:typename:int
nearest_obstacle_planes	nearobs.cpp	/^map<Node*, Plane> nearest_obstacle_planes (const vector<Node*>& nodes, $/;"	f	typeref:typename:map<Node *,Plane>
nearest_point	nearobs.cpp	/^Vec3 nearest_point (const Vec3 &x, const vector<AccelStruct*> &accs,$/;"	f	typeref:typename:Vec3
newtons_method	collision.cpp	/^double newtons_method (double a, double b, double c, double d, double x0,$/;"	f	typeref:typename:double
next_edge_ccw	mesh.hpp	/^inline Edge *next_edge_ccw(const Edge* edge, Node* center) {$/;"	f	typeref:typename:Edge *
next_edge_cw	mesh.hpp	/^inline Edge *next_edge_cw(const Edge* edge, Node* center) {$/;"	f	typeref:typename:Edge *
next_face_ccw	mesh.hpp	/^inline Face *next_face_ccw(const Edge* edge, Node* center) {$/;"	f	typeref:typename:Face *
next_face_cw	mesh.hpp	/^inline Face *next_face_cw(const Edge* edge, Node* center) {$/;"	f	typeref:typename:Face *
nf	strainlimiting.cpp	/^    int nn, nf;$/;"	m	struct:SLOpt	typeref:typename:int	file:
nlcg_value_and_grad	nlcg.cpp	/^static void nlcg_value_and_grad (const real_1d_array &x, double &value,$/;"	f	typeref:typename:void	file:
nn	strainlimiting.cpp	/^    int nn, nf;$/;"	m	struct:SLOpt	typeref:typename:int	file:
node	constraint.hpp	/^    Node *node;$/;"	m	struct:EqCon	typeref:typename:Node *
node	constraint.hpp	/^struct MeshGradV { Node* node; Vec3 f; MeshGradV(Node* i, const Vec3& f) : node(i), f(f) {} };$/;"	m	struct:MeshGradV	typeref:typename:Node *
node	display.hpp	/^	Node* node;$/;"	m	struct:Annotation	typeref:typename:Node *
node	handle.hpp	/^    Node *node;$/;"	m	struct:NodeHandle	typeref:typename:Node *
node	mesh.hpp	/^    Node *node; \/\/ world space$/;"	m	struct:Vert	typeref:typename:Node *
node	sepstrength.hpp	/^	Node* node;$/;"	m	struct:SplitNode	typeref:typename:Node *
node_box	bvh.cpp	/^BOX node_box (const Node *node, bool ccd) {$/;"	f	typeref:typename:BOX
node_edge_prox	proximity.cpp	/^static vector< Min<Edge*> > node_edge_prox;$/;"	v	typeref:typename:vector<Min<Edge * >>	file:
node_positions	simulation.cpp	/^vector<Vec3> node_positions (const vector<Mesh*> &meshes) {$/;"	f	typeref:typename:vector<Vec3>
node_prox	proximity.cpp	/^static vector< Min<Face*> > node_prox[2];$/;"	v	typeref:typename:vector<Min<Face * >>[2]	file:
nodes	collision.cpp	/^    Node *nodes[4];$/;"	m	struct:Impact	typeref:typename:Node * [4]	file:
nodes	collision.cpp	/^    vector<Node*> nodes;$/;"	m	struct:ImpactZone	typeref:typename:vector<Node * >	file:
nodes	constraint.hpp	/^    Node *nodes[2];$/;"	m	struct:GlueCon	typeref:typename:Node * [2]
nodes	constraint.hpp	/^    Node *nodes[4];$/;"	m	struct:IneqCon	typeref:typename:Node * [4]
nodes	handle.hpp	/^    Node* nodes[2];$/;"	m	struct:GlueHandle	typeref:typename:Node * [2]
nodes	localopt.cpp	/^	vector<Node*>& nodes;$/;"	m	struct:LocalOpt	typeref:typename:vector<Node * > &	file:
nodes	mesh.hpp	/^    std::vector<Node*> nodes;$/;"	m	struct:Mesh	typeref:typename:std::vector<Node * >
nodes	separateobs.cpp	/^    vector<Node*> nodes;$/;"	m	struct:SO::SeparationOpt	typeref:typename:vector<Node * >	file:
nold	separateobs.cpp	/^static map<const Face*, Vec3> nold;$/;"	v	namespace:SO	typeref:typename:map<const Face *,Vec3>	file:
nonlinear_conjugate_gradient_method	nlcg.cpp	/^void nonlinear_conjugate_gradient_method (const NLOpt &problem, OptOptions opt,$/;"	f	typeref:typename:void
nop	display.cpp	/^void nop () {} \/\/ apparently needed by GLUT 3.0$/;"	f	typeref:typename:void
norm	bvh.cpp	/^inline vec3f norm(vec3f &p1, vec3f &p2, vec3f &p3)$/;"	f	typeref:typename:vec3f
norm	lsnewton.cpp	/^static double norm (const vector<double> &x) {return sqrt(dot(x,x));}$/;"	f	typeref:typename:double	file:
norm	trustregion.cpp	/^static double norm (const vector<double> &x) {$/;"	f	typeref:typename:double	file:
norm	vectors.hpp	/^tpl T norm (const VecnT &u) {return sqrt(norm2(u));}$/;"	f	typeref:typename:tpl T
norm2	transformation.cpp	/^double norm2(const Quaternion &q) {$/;"	f	typeref:typename:double
norm2	vectors.hpp	/^tpl T norm2 (const VecnT &u) {return dot(u,u);}$/;"	f	typeref:typename:tpl T
norm2_F	vectors.hpp	/^tpl T norm2_F (const MatmnT &A) {T a = 0; for (int j = 0; j < n; j++) a += norm2(A.col(j)); retu/;"	f	typeref:typename:tpl T
norm_F	vectors.hpp	/^tpl T norm_F (const MatmnT &A) {return sqrt(norm2_F(A));}$/;"	f	typeref:typename:tpl T
normal	display.cpp	/^void normal (const Vec3 &n) {$/;"	f	typeref:typename:void
normal	geometry.cpp	/^template <Space s> Vec3 normal (const Face *face) {$/;"	f	typeref:typename:Vec3
normal	geometry.cpp	/^template <Space s> Vec3 normal (const Node* node) {$/;"	f
normal	sepstrength.hpp	/^	Vec3 normal[2];$/;"	m	struct:SplitNode	typeref:typename:Vec3[2]
normalize	handle.cpp	/^Transformation normalize (const Transformation &T) {$/;"	f	typeref:typename:Transformation
normalize	transformation.cpp	/^Quaternion normalize (const Quaternion &q) {$/;"	f	typeref:typename:Quaternion
normalize	vectors.hpp	/^tpl VecnT normalize (const VecnT &u) {T m = norm(u); return m==0 ? VecnT(0) : u\/m;}$/;"	f	typeref:typename:tpl VecnT
not_all_null	mesh.cpp	/^template <typename T1, typename T2> void not_all_null$/;"	f	typeref:typename:void
not_any_null	mesh.cpp	/^template <typename T1, typename T2> void not_any_null$/;"	f	typeref:typename:void
not_null	mesh.cpp	/^template <typename T1, typename T2> void not_null (const T1 *p1, const T2 *p2) {$/;"	f	typeref:typename:void
nsamples	dde.cpp	/^static const int nsamples = 30;$/;"	v	typeref:typename:const int	file:
nthreads	collision.cpp	/^static int nthreads = 0;$/;"	v	typeref:typename:int	file:
nthreads	separate.cpp	/^static int nthreads = 0;$/;"	v	typeref:typename:int	file:
nthreads	separateobs.cpp	/^static int nthreads = 0;$/;"	v	namespace:SO	typeref:typename:int	file:
num_bodies	mot_parser.cpp	/^size_t num_bodies(BodyVector &bodies) {$/;"	f	typeref:typename:size_t
num_frames	mot_parser.cpp	/^size_t num_frames(BodyVector &bodies) {$/;"	f	typeref:typename:size_t
nvar	optimization.hpp	/^    int nvar, ncon;$/;"	m	struct:NLConOpt	typeref:typename:int
nvar	optimization.hpp	/^    int nvar;$/;"	m	struct:NLOpt	typeref:typename:int
o	conf.cpp	/^struct Velocity {Vec3 v, w; Vec3 o;};$/;"	m	struct:Velocity	typeref:typename:Vec3	file:
obj2png_filename	display.cpp	/^string obj2png_filename;$/;"	v	typeref:typename:string
obj_grad	collision.cpp	/^void NormalOpt::obj_grad (const double *x, double *grad) const {$/;"	f	class:NormalOpt	typeref:typename:void
obj_grad	separateobs.cpp	/^void SeparationOpt::obj_grad (const double *x, double *grad) const {$/;"	f	class:SO::SeparationOpt	typeref:typename:void
obj_grad	strainlimiting.cpp	/^void SLOpt::obj_grad (const double *x, double *grad) const {$/;"	f	class:SLOpt	typeref:typename:void
objective	collision.cpp	/^double NormalOpt::objective (const double *x) const {$/;"	f	class:NormalOpt	typeref:typename:double
objective	localopt.cpp	/^double LocalOpt<s>::objective (const double *x) const {$/;"	f	class:LocalOpt	typeref:typename:double
objective	plasticity.cpp	/^double EmbedOpt::objective (const double *x) const {$/;"	f	class:EmbedOpt	typeref:typename:double
objective	popfilter.cpp	/^double PopOpt::objective (const double *x) const {$/;"	f	class:PopOpt	typeref:typename:double
objective	separateobs.cpp	/^double SeparationOpt::objective (const double *x) const {$/;"	f	class:SO::SeparationOpt	typeref:typename:double
objective	strainlimiting.cpp	/^double SLOpt::objective (const double *x) const {$/;"	f	class:SLOpt	typeref:typename:double
obs_friction	simulation.hpp	/^    double friction, obs_friction;$/;"	m	struct:Simulation	typeref:typename:double
obs_mass	collision.cpp	/^static double obs_mass;$/;"	v	typeref:typename:double	file:
obs_mass	separate.cpp	/^static double obs_mass;$/;"	v	typeref:typename:double	file:
obs_meshes	collisionutil.cpp	/^const vector<Mesh*> *meshes, *obs_meshes;$/;"	v	typeref:typename:const vector<Mesh * > *
obstacle_meshes	simulation.hpp	/^    std::vector<Mesh*> cloth_meshes, obstacle_meshes;$/;"	m	struct:Simulation	typeref:typename:std::vector<Mesh * >
obstacle_metric	dynamicremesh.cpp	/^Mat3x3 obstacle_metric (const Face *face, const map<Node*,Plane> &planes) {$/;"	f	typeref:typename:Mat3x3
obstacles	simulation.hpp	/^    std::vector<Obstacle> obstacles;$/;"	m	struct:Simulation	typeref:typename:std::vector<Obstacle>
obtain_subframe_id	io.cpp	/^string obtain_subframe_id() {$/;"	f	typeref:typename:bool load_state void save_state string
offline_loop	runphysics.cpp	/^void offline_loop() {$/;"	f	typeref:typename:void
offset	display.hpp	/^    Vec2 offset;$/;"	m	struct:Pane	typeref:typename:Vec2
opengl_fail	opengl.hpp	/^inline void opengl_fail () {$/;"	f	typeref:typename:void
operator !=	vectors.hpp	/^tpl bool operator!= (const VecnT &u, const VecnT &v) {return !(u==v);}$/;"	f	typeref:typename:tpl bool
operator ()	dynamicremesh.cpp	/^    inline bool operator()(const std::pair<double,Edge*> &left, const std::pair<double,Edge*> &r/;"	f	struct:Deterministic_sort	typeref:typename:bool	file:
operator () 	separate.cpp	/^    bool operator() (const Vec3& lhs, const Vec3& rhs) const {$/;"	f	struct:cmpOneAxis	typeref:typename:bool	file:
operator () 	sparse.hpp	/^    T &operator() (int i, int j) {\/\/ inserts entry as side-effect$/;"	f	struct:SpMat	typeref:typename:T &
operator () 	sparse.hpp	/^    T operator() (int i, int j) const {$/;"	f	struct:SpMat	typeref:typename:T
operator () 	vectors.hpp	/^    inline T &operator() (int i, int j) {return c[j][i];}$/;"	f	class:Mat	typeref:typename:T &
operator () 	vectors.hpp	/^    inline const T &operator() (int i, int j) const {return c[j][i];}$/;"	f	class:Mat	typeref:typename:const T &
operator () 	vectors.hpp	/^template <> struct static_assertion_failure<true> {void operator() () {}};$/;"	f	struct:static_assertion_failure	typeref:typename:void
operator *	spline.cpp	/^vector<double> operator* (const vector<double> &x, double a) {$/;"	f	typeref:typename:vector<double>
operator *	transformation.cpp	/^Quaternion Quaternion::operator*(const Quaternion& other) const {$/;"	f	class:Quaternion	typeref:typename:Quaternion
operator *	transformation.cpp	/^Quaternion Quaternion::operator*(double s) const {$/;"	f	class:Quaternion	typeref:typename:Quaternion
operator *	transformation.cpp	/^Transformation Transformation::operator*(const Transformation& other) const {$/;"	f	class:Transformation	typeref:typename:Transformation
operator *	transformation.cpp	/^Transformation Transformation::operator*(double s) const {$/;"	f	class:Transformation	typeref:typename:Transformation
operator *	vectors.hpp	/^inline Vec<3,double>  operator*(const Vec<3,double> &u, const Vec<3,double> &v) { __m256d r = _m/;"	f	typeref:typename:Vec<3,double>
operator *	vectors.hpp	/^template <int m, int n, int o, typename T> Mat<m,o,T> operator* (const Mat<m,n,T> &A, const Mat</;"	f	typeref:typename:Mat<m,o,T>
operator *	vectors.hpp	/^template <int m, int n, int o, typename T> Mat<m,o,T> operator* (const Mat<m,n,T> &A, const MatT/;"	f	typeref:typename:Mat<m,o,T>
operator *	vectors.hpp	/^template <int m, int n, int o, typename T> Mat<m,o,T> operator* (const MatTransposed<n,m,T> &A, /;"	f	typeref:typename:Mat<m,o,T>
operator *	vectors.hpp	/^template <int m, int n, typename T> Vec<n, T> operator* (const MatTransposed<m,n,T> &A, const Ve/;"	f	typeref:typename:Vec<n,T>
operator *	vectors.hpp	/^tpl MatmnT operator* (const MatmnT &A, const T &a) {return a*A;}$/;"	f	typeref:typename:tpl MatmnT
operator *	vectors.hpp	/^tpl MatmnT operator* (const T &a, const MatmnT &A) {MatmnT B; for (int j = 0; j < n; j++) B.col(/;"	f	typeref:typename:tpl MatmnT
operator *	vectors.hpp	/^tpl VecmT operator* (const MatmnT &A, const VecnT &u) {VecmT v = VecmT(0); for (int j = 0; j < n/;"	f	typeref:typename:tpl VecmT
operator *	vectors.hpp	/^tpl VecnT operator* (const T &a, const VecnT &u) {VecnT v; for (int i = 0; i < n; i++) v[i] = a*/;"	f	typeref:typename:tpl VecnT
operator *	vectors.hpp	/^tpl VecnT operator* (const VecnT &u, const T &a) {return a*u;}$/;"	f	typeref:typename:tpl VecnT
operator *=	vectors.hpp	/^inline Vec<3,double>& operator*=(Vec<3,double> &r, const Vec<3,double> &v)      { (__m256d&)r = /;"	f	typeref:typename:Vec<3,double> &
operator *=	vectors.hpp	/^tpl MatmnT &operator*= (MatmnT &A, const T &a) {return A = A*a;}$/;"	f	typeref:typename:tpl MatmnT &
operator *=	vectors.hpp	/^tpl MatmnT *operator*= (const MatmnT &A, const MatnnT &B) {return A = A*B;}$/;"	f	typeref:typename:tpl MatmnT *
operator *=	vectors.hpp	/^tpl VecnT &operator*= (VecnT &u, const T &a) {return u = u*a;}$/;"	f	typeref:typename:tpl VecnT &
operator +	bvh.hpp	/^	FORCEINLINE kDOP18 operator + ( const kDOP18 &v) const$/;"	f	class:kDOP18	typeref:typename:FORCEINLINE kDOP18
operator +	spline.cpp	/^vector<double> operator+ (const vector<double> &x, const vector<double> &y) {$/;"	f	typeref:typename:vector<double>
operator +	transformation.cpp	/^Quaternion Quaternion::operator+(const Quaternion& other) const {$/;"	f	class:Quaternion	typeref:typename:Quaternion
operator +	transformation.cpp	/^Transformation Transformation::operator+(const Transformation& other) const {$/;"	f	class:Transformation	typeref:typename:Transformation
operator +	vectors.hpp	/^tpl MatmnT operator+ (const MatmnT &A) {return A;}$/;"	f	typeref:typename:tpl MatmnT
operator +	vectors.hpp	/^tpl MatmnT operator+ (const MatmnT &A, const MatmnT &B) {MatmnT C; for (int j = 0; j < n; j++) C/;"	f	typeref:typename:tpl MatmnT
operator +	vectors.hpp	/^tpl VecnT operator+ (const VecnT &u) {return u;}$/;"	f	typeref:typename:tpl VecnT
operator +	vectors.hpp	/^tpl VecnT operator+ (const VecnT &u, const VecnT &v) {VecnT w; for (int i = 0; i < n; i++) w[i] /;"	f	typeref:typename:tpl VecnT
operator +=	bvh.hpp	/^	FORCEINLINE kDOP18 &operator += (const kDOP18 &b)$/;"	f	class:kDOP18	typeref:typename:FORCEINLINE kDOP18 &
operator +=	bvh.hpp	/^	FORCEINLINE kDOP18 &operator += (const vec3f &p)$/;"	f	class:kDOP18	typeref:typename:FORCEINLINE kDOP18 &
operator +=	vectors.hpp	/^tpl MatmnT &operator+= (MatmnT &A, const MatmnT &B) {return A = A + B;}$/;"	f	typeref:typename:tpl MatmnT &
operator +=	vectors.hpp	/^tpl VecnT &operator+= (VecnT &u, const VecnT &v) {return u = u + v;}$/;"	f	typeref:typename:tpl VecnT &
operator -	spline.cpp	/^vector<double> operator- (const vector<double> &x, const vector<double> &y) {$/;"	f	typeref:typename:vector<double>
operator -	transformation.cpp	/^Quaternion Quaternion::operator-() const {$/;"	f	class:Quaternion	typeref:typename:Quaternion
operator -	transformation.cpp	/^Quaternion Quaternion::operator-(const Quaternion& other) const {$/;"	f	class:Quaternion	typeref:typename:Quaternion
operator -	transformation.cpp	/^Transformation Transformation::operator-(const Transformation& other) const {$/;"	f	class:Transformation	typeref:typename:Transformation
operator -	vectors.hpp	/^tpl MatmnT operator- (const MatmnT &A) {MatmnT B; for (int j = 0; j < n; j++) B.col(j) = -A.col(/;"	f	typeref:typename:tpl MatmnT
operator -	vectors.hpp	/^tpl MatmnT operator- (const MatmnT &A, const MatmnT &B) {return A + (-B);}$/;"	f	typeref:typename:tpl MatmnT
operator -	vectors.hpp	/^tpl VecnT operator- (const VecnT &u) {VecnT v; for (int i = 0; i < n; i++) v[i] = -u[i]; return /;"	f	typeref:typename:tpl VecnT
operator -	vectors.hpp	/^tpl VecnT operator- (const VecnT &u, const VecnT &v) {return u + (-v);}$/;"	f	typeref:typename:tpl VecnT
operator -=	vectors.hpp	/^tpl MatmnT &operator-= (MatmnT &A, const MatmnT &B) {return A = A - B;}$/;"	f	typeref:typename:tpl MatmnT &
operator -=	vectors.hpp	/^tpl VecnT &operator-= (VecnT &u, const VecnT &v) {return u = u - v;}$/;"	f	typeref:typename:tpl VecnT &
operator /	spline.cpp	/^vector<double> operator\/ (const vector<double> &x, double a) {return x*(1\/a);}$/;"	f	typeref:typename:vector<double>
operator /	transformation.cpp	/^Quaternion Quaternion::operator\/(double s) const {$/;"	f	class:Quaternion	typeref:typename:Quaternion
operator /	transformation.cpp	/^Transformation Transformation::operator\/(double s) const {$/;"	f	class:Transformation	typeref:typename:Transformation
operator /	vectors.hpp	/^inline Vec<3,double>  operator\/(const Vec<3,double> &u, const Vec<3,double> &v) { __m256d r = _/;"	f	typeref:typename:Vec<3,double>
operator /	vectors.hpp	/^tpl MatmnT operator\/ (const MatmnT &A, const T &a) {return A*(1\/a);}$/;"	f	typeref:typename:tpl MatmnT
operator /	vectors.hpp	/^tpl VecnT operator\/ (const VecnT &u, const T &a) {return u*(1\/a);}$/;"	f	typeref:typename:tpl VecnT
operator /=	vectors.hpp	/^inline Vec<3,double>& operator\/=(Vec<3,double> &r, const Vec<3,double> &v)      { (__m256d&)r =/;"	f	typeref:typename:Vec<3,double> &
operator /=	vectors.hpp	/^tpl MatmnT &operator\/= (MatmnT &A, const T &a) {return A = A\/a;}$/;"	f	typeref:typename:tpl MatmnT &
operator /=	vectors.hpp	/^tpl VecnT &operator\/= (VecnT &u, const T &a) {return u = u\/a;}$/;"	f	typeref:typename:tpl VecnT &
operator <	collision.cpp	/^bool operator< (const Impact &impact0, const Impact &impact1) {$/;"	f	typeref:typename:bool
operator <	sepstrength.hpp	/^    bool operator<(const SplitNode& o) const { return sep < o.sep; }$/;"	f	struct:SplitNode	typeref:typename:bool
operator <<	remesh.cpp	/^ostream &operator<< (ostream &out, const RemeshOp &op) {$/;"	f	typeref:typename:ostream &
operator <<	separateobs.cpp	/^ostream &operator<< (ostream &out, const Ixn &ixn) {out << ixn.f0 << "@" << ixn.b0 << " " << ixn/;"	f	namespace:SO	typeref:typename:ostream &
operator <<	sparse.hpp	/^std::ostream &operator<< (std::ostream &out, const SpMat<T> &A) {$/;"	f	typeref:typename:std::ostream &
operator <<	sparse.hpp	/^std::ostream &operator<< (std::ostream &out, const SpVec<T> &v) {$/;"	f	typeref:typename:std::ostream &
operator <<	taucs.cpp	/^ostream &operator<< (ostream &out, taucs_ccs_matrix *A) {$/;"	f	typeref:typename:ostream &
operator <<	tensormax.cpp	/^ostream &operator<< (ostream &out, const Disk &disk) {out << "Circle[{" << disk.c[0] << "," << d/;"	f	typeref:typename:ostream &
operator <<	transformation.hpp	/^inline std::ostream &operator<< (std::ostream &out, const Quaternion &q) {out << "(" << q.s << "/;"	f	typeref:typename:std::ostream &
operator <<	transformation.hpp	/^inline std::ostream &operator<< (std::ostream &out, const Transformation &t) {out << "(translati/;"	f	typeref:typename:std::ostream &
operator <<	util.cpp	/^ostream &operator<< (ostream &out, const Edge *edge) {$/;"	f	typeref:typename:ostream &
operator <<	util.cpp	/^ostream &operator<< (ostream &out, const Face *face) {$/;"	f	typeref:typename:ostream &
operator <<	util.cpp	/^ostream &operator<< (ostream &out, const Node *node) {$/;"	f	typeref:typename:ostream &
operator <<	util.cpp	/^ostream &operator<< (ostream &out, const Stats &stats) {$/;"	f	typeref:typename:ostream &
operator <<	util.cpp	/^ostream &operator<< (ostream &out, const Vert *vert) {$/;"	f	typeref:typename:ostream &
operator <<	util.hpp	/^std::ostream &operator<< (std::ostream &out, const std::vector<T> &v) {$/;"	f	typeref:typename:std::ostream &
operator <<	vectors.hpp	/^tpl std::ostream &operator<< (std::ostream &out, const MatmnT &A) {MatnmT At = transpose(A); out/;"	f	typeref:typename:tpl std::ostream &
operator <<	vectors.hpp	/^tpl std::ostream &operator<< (std::ostream &out, const VecnT &u) {out << "("; for (int i = 0; i /;"	f	typeref:typename:tpl std::ostream &
operator ==	vectors.hpp	/^tpl bool operator== (const VecnT &u, const VecnT &v) {for(int i=0; i<n; ++i) if(u[i] != v[i]) re/;"	f	typeref:typename:tpl bool
operator [] 	sparse.hpp	/^    T &operator[] (int i) {\/\/ inserts entry as side-effect$/;"	f	struct:SpVec	typeref:typename:T &
operator [] 	sparse.hpp	/^    T operator[] (int i) const {$/;"	f	struct:SpVec	typeref:typename:T
operator [] 	vectors.hpp	/^    T &operator[] (int i) {return c[i];}$/;"	f	class:Vec	typeref:typename:T &
operator [] 	vectors.hpp	/^    const T &operator[] (int i) const {return c[i];}$/;"	f	class:Vec	typeref:typename:const T &
operator delete	vectors.hpp	/^inline void  operator delete(void *ptr)   { aligned_free(ptr); }$/;"	f	typeref:typename:void
operator delete[]	vectors.hpp	/^inline void  operator delete[](void *ptr) { aligned_free(ptr); }$/;"	f	typeref:typename:void
operator new	vectors.hpp	/^inline void* operator new(size_t sz)      { return malloc_align(sz); }$/;"	f	typeref:typename:void *
operator new[]	vectors.hpp	/^inline void* operator new[](size_t sz)    { return malloc_align(sz); }$/;"	f	typeref:typename:void *
optimize_node	remesh.cpp	/^void optimize_node (Node *node) {$/;"	f	typeref:typename:void
optimize_plastic_embedding	plasticity.cpp	/^void optimize_plastic_embedding (Cloth &cloth) {$/;"	f	typeref:typename:void
orient	mot_parser.hpp	/^    Vec4 orient;$/;"	m	struct:BodyFrame	typeref:typename:Vec4
origami_color	display.cpp	/^Vec3 origami_color (const Mat3x3& M) {$/;"	f	typeref:typename:Vec3
other_node	mesh.hpp	/^inline Node *other_node (const Edge* edge, const Node* node0) {$/;"	f	typeref:typename:Node *
outer	vectors.hpp	/^tpl MatmnT outer (const VecmT &u, const VecnT &v) {MatmnT A; for (int j = 0; j < n; j++) A.col(j/;"	f	typeref:typename:tpl MatmnT
outprefix	runphysics.cpp	/^string inprefix, outprefix;$/;"	v	typeref:typename:string
overlap	bvh.cpp	/^bool overlap (const BOX &box0, const BOX &box1, float thickness) {$/;"	f	typeref:typename:bool
overlaps	bvh.hpp	/^	FORCEINLINE bool overlaps(const kDOP18 &b, kDOP18 &ret) const$/;"	f	class:kDOP18	typeref:typename:FORCEINLINE bool
overlaps	bvh.hpp	/^	FORCEINLINE bool overlaps(const kDOP18& b) const$/;"	f	class:kDOP18	typeref:typename:FORCEINLINE bool
panes	display.cpp	/^Pane Pane::panes[3] = { false, false, true };$/;"	m	class:Pane	typeref:typename:Pane[3]
panes	display.hpp	/^    static Pane panes[3];$/;"	m	struct:Pane	typeref:typename:Pane[3]
parent	display.hpp	/^    int window, parent;$/;"	m	struct:Pane	typeref:typename:int
parent	mesh.hpp	/^	Cloth* parent;$/;"	m	struct:Mesh	typeref:typename:Cloth *
parent	separate.cpp	/^    vector<size_t> parent, rank;$/;"	m	struct:UnionFind	typeref:typename:vector<size_t>	file:
parse	conf.cpp	/^template <int n> void parse (Vec<n> &v, const Json::Value &json) {$/;"	f	typeref:typename:void
parse	conf.cpp	/^template <typename T> void parse (T &x, const Json::Value &json, const T &x0) {$/;"	f	typeref:typename:void
parse	conf.cpp	/^template <typename T> void parse (vector<T> &v, const Json::Value &json) {$/;"	f	typeref:typename:void
parse	conf.cpp	/^void parse (BendingData &data, const Json::Value &json) {$/;"	f	typeref:typename:void
parse	conf.cpp	/^void parse (Box &box, const Json::Value &json, const Box &box0) {$/;"	f	typeref:typename:void
parse	conf.cpp	/^void parse (Cloth &cloth, const Json::Value &json) {$/;"	f	typeref:typename:void
parse	conf.cpp	/^void parse (Magic &magic, const Json::Value &json) {$/;"	f	typeref:typename:void
parse	conf.cpp	/^void parse (Material *&material, const Json::Value &json) {$/;"	f	typeref:typename:void
parse	conf.cpp	/^void parse (Motion &motion, const Json::Value &json) {$/;"	f	typeref:typename:void
parse	conf.cpp	/^void parse (Motion::Point &mp, const Json::Value &json) {$/;"	f	typeref:typename:void
parse	conf.cpp	/^void parse (Range range, const Json::Value &json, Vec2 range0) {$/;"	f	typeref:typename:void
parse	conf.cpp	/^void parse (Remeshing &remeshing, const Json::Value &json) {$/;"	f	typeref:typename:void
parse	conf.cpp	/^void parse (StretchingSamples &samples, const Json::Value &json) {$/;"	f	typeref:typename:void
parse	conf.cpp	/^void parse (Transformation& transform, const Json::Value &json) {$/;"	f	typeref:typename:void
parse	conf.cpp	/^void parse (Velocity &velocity, const Json::Value &json) {$/;"	f	typeref:typename:void
parse	conf.cpp	/^void parse (Wind &wind, const Json::Value &json) {$/;"	f	typeref:typename:void
parse	conf.cpp	/^void parse (bool &b, const Json::Value &json) {$/;"	f	typeref:typename:void
parse	conf.cpp	/^void parse (double &x, const Json::Value &json) {$/;"	f	typeref:typename:void
parse	conf.cpp	/^void parse (int &n, const Json::Value &json) {$/;"	f	typeref:typename:void
parse	conf.cpp	/^void parse (string &s, const Json::Value &json) {$/;"	f	typeref:typename:void
parse_circle_handle	conf.cpp	/^void parse_circle_handle (vector<Handle*> &hans, const Json::Value &json,$/;"	f	typeref:typename:void
parse_glue_handle	conf.cpp	/^void parse_glue_handle (vector<Handle*> &hans, const Json::Value &json,$/;"	f	typeref:typename:void
parse_handle	conf.cpp	/^void parse_handle (vector<Handle*> &hans, const Json::Value &json,$/;"	f	typeref:typename:void
parse_handles	conf.cpp	/^void parse_handles (vector<Handle*> &hans, const Json::Value &jsons,$/;"	f	typeref:typename:void
parse_morph	conf.cpp	/^void parse_morph (Morph &morph, const Json::Value &json,$/;"	f	typeref:typename:void
parse_morphs	conf.cpp	/^void parse_morphs (vector<Morph> &morphs, const Json::Value &json,$/;"	f	typeref:typename:void
parse_motions	conf.cpp	/^void parse_motions (vector<Motion> &motions, const Json::Value &json) {$/;"	f	typeref:typename:void
parse_node_handle	conf.cpp	/^void parse_node_handle (vector<Handle*> &hans, const Json::Value &json,$/;"	f	typeref:typename:void
parse_obstacle	conf.cpp	/^void parse_obstacle (Obstacle &obstacle, const Json::Value &json,$/;"	f	typeref:typename:void
parse_obstacles	conf.cpp	/^void parse_obstacles (vector<Obstacle> &obstacles, const Json::Value &json,$/;"	f	typeref:typename:void
parse_soft_handle	conf.cpp	/^void parse_soft_handle (vector<Handle*> &hans, const Json::Value &json,$/;"	f	typeref:typename:void
passive_time	simulation.hpp	/^    double passive_time;$/;"	m	struct:Simulation	typeref:typename:double
perform_breaking	breaking.cpp	/^void perform_breaking(Mesh& mesh) {$/;"	f	typeref:typename:void
perp	dynamicremesh.cpp	/^Mat2x2 perp (const Mat2x2 &A) {return Mat2x2(Vec2(A(1,1), -A(1,0)),$/;"	f	typeref:typename:Mat2x2
perp	vectors.hpp	/^template <typename T> Vec<2,T> perp (const Vec<2,T> &u) {return Vec<2,T>(-u[1],u[0]);}$/;"	f	typeref:typename:Vec<2,T>
physics	simulation.cpp	/^                 physics = Simulation::Physics,$/;"	v	typeref:typename:const int	file:
physics_step	simulation.cpp	/^void physics_step (Simulation &sim, const vector<Constraint*> &cons) {$/;"	f	typeref:typename:void
plane_fit	geometry.cpp	/^Plane plane_fit(const Mesh& mesh) {$/;"	f	typeref:typename:Plane
plastic	display.hpp	/^	static Pane& plastic() { return panes[1]; }$/;"	f	struct:Pane	typeref:typename:Pane &
plastic_flow	cloth.hpp	/^    double yield_stretch, plastic_flow, plastic_limit;$/;"	m	struct:Material	typeref:typename:double
plastic_limit	cloth.hpp	/^    double yield_stretch, plastic_flow, plastic_limit;$/;"	m	struct:Material	typeref:typename:double
plastic_update	plasticity.cpp	/^void plastic_update (Cloth &cloth) {$/;"	f	typeref:typename:void
plasticity	simulation.cpp	/^                 plasticity = Simulation::Plasticity,$/;"	v	typeref:typename:const int	file:
plasticity_color	display.cpp	/^Vec3 plasticity_color (const Face *face) {$/;"	f	typeref:typename:Vec3
plasticity_from_embedding	remesh.cpp	/^void plasticity_from_embedding (const vector<Face*> &faces) {$/;"	f	typeref:typename:void
plasticity_step	simulation.cpp	/^void plasticity_step (Simulation &sim) {$/;"	f	typeref:typename:void
point_box_distance	nearobs.cpp	/^double point_box_distance (const Vec3 &x, const BOX &box) {$/;"	f	typeref:typename:double
points	spline.hpp	/^    std::vector<Point> points;$/;"	m	class:Spline	typeref:typename:std::vector<Point>
popfilter	simulation.cpp	/^                 popfilter = Simulation::PopFilter,$/;"	v	typeref:typename:const int	file:
pos	collision.cpp	/^Vec3 pos (const Node *node, double t) {$/;"	f	typeref:typename:Vec3
pos	display.cpp	/^Vec3 Pane::pos(Vert* v) {$/;"	f	class:Pane	typeref:typename:Vec3
pos	display.hpp	/^	Vec3 pos, dir;$/;"	m	struct:Annotation	typeref:typename:Vec3
pos	geometry.hpp	/^template <> inline Vec3 &pos<MS> (Vert *vert) {return vert->u;}$/;"	f	typeref:typename:Vec3 &
pos	geometry.hpp	/^template <> inline Vec3 &pos<PS> (Node *node) {return node->y;}$/;"	f	typeref:typename:Vec3 &
pos	geometry.hpp	/^template <> inline Vec3 &pos<PS> (Vert *vert) {return vert->node->y;}$/;"	f	typeref:typename:Vec3 &
pos	geometry.hpp	/^template <> inline Vec3 &pos<WS> (Node *node) {return node->x;}$/;"	f	typeref:typename:Vec3 &
pos	geometry.hpp	/^template <> inline Vec3 &pos<WS> (Vert *vert) {return vert->node->x;}$/;"	f	typeref:typename:Vec3 &
pos	geometry.hpp	/^template <> inline const Vec3 &pos<MS> (const Vert *vert) {return vert->u;}$/;"	f	typeref:typename:const Vec3 &
pos	geometry.hpp	/^template <> inline const Vec3 &pos<PS> (const Node *node) {return node->y;}$/;"	f	typeref:typename:const Vec3 &
pos	geometry.hpp	/^template <> inline const Vec3 &pos<PS> (const Vert *vert) {return vert->node->y;}$/;"	f	typeref:typename:const Vec3 &
pos	geometry.hpp	/^template <> inline const Vec3 &pos<WS> (const Node *node) {return node->x;}$/;"	f	typeref:typename:const Vec3 &
pos	geometry.hpp	/^template <> inline const Vec3 &pos<WS> (const Vert *vert) {return vert->node->x;}$/;"	f	typeref:typename:const Vec3 &
pos	morph.cpp	/^Vec3 Morph::pos (double t, const Vec3 &u) const {$/;"	f	class:Morph	typeref:typename:Vec3
pos	mot_parser.hpp	/^    Vec3 pos;$/;"	m	struct:BodyFrame	typeref:typename:Vec3
pos	separate.cpp	/^Vec3 pos (const Face *face, const Bary &b) {$/;"	f	typeref:typename:Vec3
pos	separateobs.cpp	/^Vec3 pos (const Face *face, const Bary &b) {$/;"	f	namespace:SO	typeref:typename:Vec3
pos	spline.cpp	/^T Spline<T>::pos (double t) const {$/;"	f	class:Spline	typeref:typename:T
precompute	collision.cpp	/^void NormalOpt::precompute (const double *x) const {$/;"	f	class:NormalOpt	typeref:typename:void
precompute	localopt.cpp	/^void LocalOpt<s>::precompute (const double *x) const {$/;"	f	class:LocalOpt	typeref:typename:void
precompute	optimization.hpp	/^    virtual void precompute (const double *x) const {}$/;"	f	struct:NLConOpt	typeref:typename:void
precompute	optimization.hpp	/^    virtual void precompute (const double *x) const {}$/;"	f	struct:NLOpt	typeref:typename:void
precompute	plasticity.cpp	/^void EmbedOpt::precompute (const double *x) const {$/;"	f	class:EmbedOpt	typeref:typename:void
precompute	popfilter.cpp	/^void PopOpt::precompute (const double *x) const {$/;"	f	class:PopOpt	typeref:typename:void
precompute	strainlimiting.cpp	/^void SLOpt::precompute (const double *x) const {$/;"	f	class:SLOpt	typeref:typename:void
prepare	simulation.cpp	/^void prepare (Simulation &sim) {$/;"	f	typeref:typename:void
preserve	mesh.hpp	/^    bool preserve; \/\/ don't remove this node$/;"	m	struct:Node	typeref:typename:bool
preserve	mesh.hpp	/^    int preserve;$/;"	m	struct:Edge	typeref:typename:int
preserve_creases	magic.hpp	/^    bool preserve_creases;$/;"	m	struct:Magic	typeref:typename:bool
problem	auglag.cpp	/^static const NLConOpt *problem;$/;"	v	typeref:typename:const NLConOpt *	file:
problem	lbfgs.cpp	/^static const NLOpt *problem;$/;"	v	typeref:typename:const NLOpt *	file:
problem	nlcg.cpp	/^static const NLOpt *problem;$/;"	v	typeref:typename:const NLOpt *	file:
project	constraint.cpp	/^MeshGrad EqCon::project () {return MeshGrad();}$/;"	f	class:EqCon	typeref:typename:MeshGrad
project	constraint.cpp	/^MeshGrad GlueCon::project () {return MeshGrad();}$/;"	f	class:GlueCon	typeref:typename:MeshGrad
project	constraint.cpp	/^MeshGrad IneqCon::project () {$/;"	f	class:IneqCon	typeref:typename:MeshGrad
project	vectors.hpp	/^template <int m, int n, typename T> Vec<m,T> project (const VecnT &u) {Vec<m,T> v; for (int i = /;"	f	typeref:typename:Vec<m,T>
project	vectors.hpp	/^template <int m1, int n1, int m2, int n2, typename T> Mat<m1,n1,T> project (const Mat<m2,n2,T> &/;"	f	typeref:typename:Mat<m1,n1,T>
project_outside	physics.cpp	/^void project_outside (vector<Node*>& nodes, const vector<Constraint*> &cons) {$/;"	f	typeref:typename:void
project_vertex	remesh.cpp	/^void project_vertex(Vert *vnew, Edge* edge, int s, double d) {$/;"	f	typeref:typename:void
projected_curvature	geometry.cpp	/^template <Space s> Mat2x2 projected_curvature (const Face *face, const Mat2x3& base) {$/;"	f	typeref:typename:double dihedral_angle double dihedral_angle double dihedral_angle Mat2x2
projection_thickness	magic.hpp	/^    double repulsion_thickness, projection_thickness;$/;"	m	struct:Magic	typeref:typename:double
proximity	simulation.cpp	/^static const int proximity = Simulation::Proximity,$/;"	v	typeref:typename:const int	file:
proximity_constraints	proximity.cpp	/^vector<Constraint*> proximity_constraints (vector<Mesh*> &meshes,$/;"	f	typeref:typename:vector<Constraint * >
proxy	mesh.hpp	/^    CollisionProxy* proxy;$/;"	m	struct:Mesh	typeref:typename:CollisionProxy *
quantile	util.cpp	/^double Stats::quantile (double q) const {sort(); return xs[(int)(q*xs.size())];}$/;"	f	class:Stats	typeref:typename:double
r	tensormax.cpp	/^    double r;$/;"	m	struct:Disk	typeref:typename:double	file:
r	vectors.hpp	/^template<> inline Vec<3,double> operator*<3,double>(const double &a, const Vec<3,double> &v) { _/;"	v	typeref:typename:__m256d
r	vectors.hpp	/^template<> inline Vec<3,double> operator+<3,double>(const Vec<3,double> &u, const Vec<3,double> /;"	v	typeref:typename:__m256d
r	vectors.hpp	/^template<> inline Vec<3,double> operator-<3,double>(const Vec<3,double> &u, const Vec<3,double> /;"	v	typeref:typename:__m256d
r	vectors.hpp	/^template<> inline Vec<3,double> operator\/<3,double>(const Vec<3,double> &u, const double &a) { /;"	v	typeref:typename:__m256d
radius	handle.hpp	/^    double radius;$/;"	m	struct:SoftHandle	typeref:typename:double
radius	referenceshape.hpp	/^    double radius;$/;"	m	class:ReferenceSphere	typeref:typename:double
random	displaytesting.cpp	/^template <int n> Vec<n> random () {$/;"	f	typeref:typename:Vec<n>
rank	separate.cpp	/^    vector<size_t> parent, rank;$/;"	m	struct:UnionFind	typeref:typename:vector<size_t>	file:
raycast	referenceshape.cpp	/^bool ReferenceLinear::raycast(Vec3& p, const Vec3& dir) {$/;"	f	class:ReferenceLinear	typeref:typename:bool
raycast	referenceshape.cpp	/^bool ReferenceMesh::raycast(Vec3& p, const Vec3& dir) {$/;"	f	class:ReferenceMesh	typeref:typename:bool
raycast	referenceshape.cpp	/^bool ReferenceSphere::raycast(Vec3& p, const Vec3& dir) {$/;"	f	class:ReferenceSphere	typeref:typename:bool
read_motion_file	mot_parser.cpp	/^BodyVector read_motion_file(const string& filename) {$/;"	f	typeref:typename:BodyVector
read_motion_file	mot_parser.cpp	/^BodyVector read_motion_file(std::istream& istr) {$/;"	f	typeref:typename:BodyVector
recompute_Sp_bend	plasticity.cpp	/^void recompute_Sp_bend (Face *face) {$/;"	f	typeref:typename:void
recompute_edge_plasticity	plasticity.cpp	/^void recompute_edge_plasticity (Mesh &mesh) {$/;"	f	typeref:typename:void
recompute_support	subset.cpp	/^void MeshSubset::recompute_support(map<Node*,int>& acc) {$/;"	f	class:MeshSubset	typeref:typename:void
recover_plasticity	displaytesting.cpp	/^static void recover_plasticity (Mesh &mesh) {$/;"	f	typeref:typename:void	file:
red_blue_colorscheme	display.cpp	/^Vec3 red_blue_colorscheme(double v) {$/;"	f	typeref:typename:Vec3
redisplay	display.cpp	/^void redisplay () {$/;"	f	typeref:typename:void
reduce_stretching_stiffnesses	plasticity.cpp	/^void reduce_stretching_stiffnesses (vector<Material*> &materials) {$/;"	f	typeref:typename:void
reduce_xy	vectors.hpp	/^inline Mat<2,2> reduce_xy (const Mat<3,3>& M) { return Mat<2,2> (Vec2(M(0,0),M(0,1)),Vec2(M(1,0)/;"	f	typeref:typename:Mat<2,2>
reduce_xy	vectors.hpp	/^inline Vec<2> reduce_xy(const Vec<3>& v) { return Vec<2>(v[0],v[1]); }$/;"	f	typeref:typename:Vec<2>
ref	mesh.hpp	/^	ReferenceShape *ref;$/;"	m	struct:Mesh	typeref:typename:ReferenceShape *
refine_angle	cloth.hpp	/^    double refine_angle, refine_compression, refine_velocity;$/;"	m	struct:Remeshing	typeref:typename:double
refine_compression	cloth.hpp	/^    double refine_angle, refine_compression, refine_velocity;$/;"	m	struct:Remeshing	typeref:typename:double
refine_fracture	cloth.hpp	/^    double refine_fracture;$/;"	m	struct:Remeshing	typeref:typename:double
refine_velocity	cloth.hpp	/^    double refine_angle, refine_compression, refine_velocity;$/;"	m	struct:Remeshing	typeref:typename:double
refit	bvh.cpp	/^DeformBVHNode::refit(bool ccd)$/;"	f	class:DeformBVHNode	typeref:typename:void
refit	bvh.cpp	/^DeformBVHTree::refit()$/;"	f	class:DeformBVHTree	typeref:typename:float
relax_initial_state	simulation.cpp	/^void relax_initial_state (Simulation &sim) {$/;"	f	typeref:typename:void
relax_method	magic.hpp	/^    int relax_method, max_cracks;$/;"	m	struct:Magic	typeref:typename:int
reload	displayreplay.cpp	/^static void reload () {$/;"	f	typeref:typename:void	file:
remeshing	cloth.hpp	/^    Remeshing remeshing;$/;"	m	struct:Cloth	typeref:typename:Remeshing
remeshing	simulation.cpp	/^                 remeshing = Simulation::Remeshing,$/;"	v	typeref:typename:const int	file:
remeshing_step	displaytesting.cpp	/^static void remeshing_step (Cloth &cloth) {$/;"	f	typeref:typename:void	file:
remeshing_step	simulation.cpp	/^void remeshing_step (Simulation &sim, bool initializing) {$/;"	f	typeref:typename:void
remove	mesh.cpp	/^void Mesh::remove (Edge *edge) {$/;"	f	class:Mesh	typeref:typename:void
remove	mesh.cpp	/^void Mesh::remove (Face* face) {$/;"	f	class:Mesh	typeref:typename:void
remove	mesh.cpp	/^void Mesh::remove (Node* node) {$/;"	f	class:Mesh	typeref:typename:void
remove	mesh.cpp	/^void Mesh::remove (Vert* vert) {$/;"	f	class:Mesh	typeref:typename:void
remove	util.hpp	/^template <typename T> inline void remove (int i, std::vector<T> &xs) {$/;"	f	typeref:typename:void
remove_all	remesh.cpp	/^template <class T> static void remove_all(const vector<T>& a, Mesh& m) { for(size_t i=0; i<a.siz/;"	f	typeref:typename:void	file:
removed_edges	remesh.hpp	/^    std::vector<Edge*> added_edges, removed_edges;$/;"	m	struct:RemeshOp	typeref:typename:std::vector<Edge * >
removed_faces	remesh.hpp	/^    std::vector<Face*> added_faces, removed_faces;$/;"	m	struct:RemeshOp	typeref:typename:std::vector<Face * >
removed_nodes	remesh.hpp	/^    std::vector<Node*> added_nodes, removed_nodes;$/;"	m	struct:RemeshOp	typeref:typename:std::vector<Node * >
removed_verts	remesh.hpp	/^    std::vector<Vert*> added_verts, removed_verts;$/;"	m	struct:RemeshOp	typeref:typename:std::vector<Vert * >
reorient_MS	conf.cpp	/^void reorient_MS(Mesh& mesh) {$/;"	f	typeref:typename:void
replace	util.hpp	/^inline void replace (const T &x0, const T &x1, std::vector<T> &xs) {$/;"	f	typeref:typename:void
replace	util.hpp	/^template <typename T> inline void replace (const T &v0, const T &v1, T vs[3]) {$/;"	f	typeref:typename:void
reproject_all	conf.cpp	/^void reproject_all(Mesh& mesh) {$/;"	f	typeref:typename:void
repulsion_thickness	magic.hpp	/^    double repulsion_thickness, projection_thickness;$/;"	m	struct:Magic	typeref:typename:double
reset_plasticity	plasticity.cpp	/^void reset_plasticity (Cloth &cloth) {$/;"	f	typeref:typename:void
reshape	display.cpp	/^void reshape (int w, int h) {$/;"	f	typeref:typename:void
resize	mot_parser.cpp	/^void resize(BodyVector &bodies, size_t nbodies, size_t nframes) {$/;"	f	typeref:typename:void
restore_stretching_stiffnesses	plasticity.cpp	/^void restore_stretching_stiffnesses (vector<Material*> &materials) {$/;"	f	typeref:typename:void
resume_physics	runphysics.cpp	/^void resume_physics (const vector<string> &args) {$/;"	f	typeref:typename:void
rib_stiffening	magic.hpp	/^    double rib_stiffening;$/;"	m	struct:Magic	typeref:typename:double
right_handed	vectors.hpp	/^template <typename T> bool right_handed (const Vec<3,T> &u, const Vec<3,T> &v, const Vec<3,T> &w/;"	f	typeref:typename:bool
root	collisionutil.hpp	/^    BVHNode *root;$/;"	m	struct:AccelStruct	typeref:typename:BVHNode *
rotate	transformation.cpp	/^Vec3 Quaternion::rotate (const Vec3 &x) const {$/;"	f	class:Quaternion	typeref:typename:Vec3
rotation	transformation.hpp	/^    Quaternion rotation;$/;"	m	struct:Transformation	typeref:typename:Quaternion
row	vectors.hpp	/^    VecnT row (int i) const {VecnT R; for(int col = 0; col < n; ++col) { R[col] = c[col][i]; } r/;"	f	class:Mat	typeref:typename:VecnT
rowmat	physics.cpp	/^template <int n> Mat<1,n> rowmat (const Vec<n> &v) {$/;"	f	typeref:typename:Mat<1,n>
rows	sparse.hpp	/^    std::vector< SpVec<T> > rows;$/;"	m	struct:SpMat	typeref:typename:std::vector<SpVec<T>>
rows	vectors.hpp	/^	static Mat rows (VecnT x, VecnT y) { Mat<2,n,T> M; for(int i = 0; i < n; i++) { M.col(i)[0] = x/;"	f	class:Mat	typeref:typename:Mat
rows	vectors.hpp	/^    static Mat rows (VecnT x, VecnT y, VecnT z) { Mat<3,n,T> M; for(int i = 0; i < n; i++) { M.c/;"	f	class:Mat	typeref:typename:Mat
rows	vectors.hpp	/^    static Mat rows (VecnT x, VecnT y, VecnT z, VecnT w) { Mat<4,n,T> M; for(int i = 0; i < n; i/;"	f	class:Mat	typeref:typename:Mat
run	main.cpp	/^        void (*run) (const vector<string> &args);$/;"	m	struct:main::Action	typeref:typename:void (*)(const vector<string> & args)	file:
run_glut	display.cpp	/^void run_glut() {$/;"	f	typeref:typename:void
run_physics	runphysics.cpp	/^void run_physics (const vector<string> &args) {$/;"	f	typeref:typename:void
running	displayphysics.cpp	/^static bool running = false;$/;"	v	typeref:typename:bool	file:
running	displayreplay.cpp	/^static bool running = false;$/;"	v	typeref:typename:bool	file:
s	dde.hpp	/^struct StretchingSamples {Vec4 s[40][40][40];};$/;"	m	struct:StretchingSamples	typeref:typename:Vec4[40][40][40]
s	strainlimiting.cpp	/^    mutable vector<double> s;$/;"	m	struct:SLOpt	typeref:typename:vector<double>	file:
s	transformation.hpp	/^    double s;$/;"	m	struct:Quaternion	typeref:typename:double
s	vectors.hpp	/^    Vec<n> s;$/;"	m	struct:SVD	typeref:typename:Vec<n>
safe_normal	remesh.cpp	/^Vec3 safe_normal(Face* face) {$/;"	f	typeref:typename:Vec3
save	runphysics.cpp	/^static void save (vector<Mesh*> &meshes, int frame) {$/;"	f	typeref:typename:void	file:
save	runphysics.cpp	/^void save (Simulation &sim, int frame) {$/;"	f	typeref:typename:void
save	util.hpp	/^	bool save() { return mode == Save; }$/;"	f	struct:Serialize	typeref:typename:bool
save_every	simulation.hpp	/^    int frame_steps, save_every;$/;"	m	struct:Simulation	typeref:typename:int
save_obj	io.cpp	/^void save_obj (const Mesh &mesh, const string &filename) {$/;"	f	typeref:typename:void
save_objs	io.cpp	/^void save_objs (const vector<Mesh*> &meshes, const string &prefix) {$/;"	f	typeref:typename:void
save_obstacle_transforms	displayreplay.cpp	/^static void save_obstacle_transforms (const vector<Obstacle> &obs, int frame,$/;"	f	typeref:typename:void	file:
save_png	io.cpp	/^void save_png (const char *filename, int width, int height,$/;"	f	typeref:typename:void
save_screenshot	io.cpp	/^void save_screenshot (const string &filename) {$/;"	f	typeref:typename:void
save_state	io.cpp	/^void save_state (T& state, const string &prefix) {$/;"	f	typeref:typename:void
save_timings	runphysics.cpp	/^static void save_timings () {$/;"	f	typeref:typename:void	file:
save_transformation	io.cpp	/^void save_transformation (const Transformation &tr, const string &filename) {$/;"	f	typeref:typename:void
scalar_mult	lsnewton.cpp	/^static void scalar_mult (vector<double> &v, double a, const vector<double> &x) {$/;"	f	typeref:typename:void	file:
scalar_mult	trustregion.cpp	/^static void scalar_mult (vector<double> &v, double a, const vector<double> &x) {$/;"	f	typeref:typename:void	file:
scale	display.cpp	/^struct DisplayMode { string name; double scale; bool active; };$/;"	m	struct:DisplayMode	typeref:typename:double	file:
scale	display.hpp	/^    double scale;$/;"	m	struct:Pane	typeref:typename:double
scale	transformation.hpp	/^    double scale;$/;"	m	struct:Transformation	typeref:typename:double
segfault	util.cpp	/^void segfault() {$/;"	f	typeref:typename:void
select_element	display.cpp	/^void select_element(int x, int y, int button) {$/;"	f	typeref:typename:void
sep	mesh.hpp	/^	double sep;$/;"	m	struct:Node	typeref:typename:double
sep	sepstrength.hpp	/^	double sep;$/;"	m	struct:SplitNode	typeref:typename:double
separate	separate.cpp	/^void separate (vector<Mesh*> &meshes, const vector<Mesh*> &obs_meshes) {$/;"	f	typeref:typename:void
separate_obstacles	separateobs.cpp	/^void separate_obstacles (vector<Mesh*> &obs_meshes,$/;"	f	namespace:SO	typeref:typename:void
separate_obstacles	separateobs.cpp	/^void separate_obstacles (vector<Mesh*> &obs_meshes,$/;"	f	typeref:typename:void
separation	simulation.cpp	/^                 separation = Simulation::Separation,$/;"	v	typeref:typename:const int	file:
separation_step_size	magic.hpp	/^    double separation_step_size;$/;"	m	struct:Magic	typeref:typename:double
separation_strength	sepstrength.cpp	/^double separation_strength(Node* node, SplitNode* split, bool always_compute) {$/;"	f	typeref:typename:double
serialize_header	io.cpp	/^void serialize_header(Serialize& s) {$/;"	f	typeref:typename:void
serialize_link	mesh.cpp	/^template<class T> void serialize_link(T*& p, vector<T*>& src, Serialize& s, const string& id) {$/;"	f	typeref:typename:void
serialize_links	mesh.cpp	/^template<class T> void serialize_links(vector<T*>& v, vector<T*>& src, Serialize& s, const strin/;"	f	typeref:typename:void
serialize_minvec	proximity.cpp	/^template<class T> void serialize_minvec(vector<Min<T*> >& v, Serialize& s, const string& name) {$/;"	f	typeref:typename:void
serialize_vector	mesh.cpp	/^template<class T> void serialize_vector(vector<T*>& v, Serialize &s, const string& id) {$/;"	f	typeref:typename:void
serializer	constraint.cpp	/^template<> void serializer<vector<Constraint*> >(vector<Constraint*>& x, Serialize& s, const str/;"	f	typeref:typename:void
serializer	constraint.cpp	/^void IneqCon::serializer(Serialize& s, const std::string& name) {$/;"	f	class:IneqCon	typeref:typename:void
serializer	constraint.hpp	/^    virtual void serializer(Serialize& s, const std::string& name) {};$/;"	f	struct:Constraint	typeref:typename:void
serializer	io.cpp	/^template<> void serializer<Simulation>(Simulation& sim, Serialize& s, const string& n) {$/;"	f	typeref:typename:void
serializer	mesh.cpp	/^void Edge::serializer(Serialize& s) {$/;"	f	class:Edge	typeref:typename:void
serializer	mesh.cpp	/^void Face::serializer(Serialize& s) {$/;"	f	class:Face	typeref:typename:void
serializer	mesh.cpp	/^void Mesh::serializer(Serialize& s) {$/;"	f	class:Mesh	typeref:typename:void
serializer	mesh.cpp	/^void Node::serializer(Serialize& s) {$/;"	f	class:Node	typeref:typename:void
serializer	mesh.cpp	/^void Vert::serializer(Serialize& s) {$/;"	f	class:Vert	typeref:typename:void
serializer	proximity.cpp	/^template<> void serializer<vector<Min<Edge*> > >(vector<Min<Edge*> >& x, Serialize& s, const str/;"	f	typeref:typename:void
serializer	proximity.cpp	/^template<> void serializer<vector<Min<Face*> > >(vector<Min<Face*> >& x, Serialize& s, const str/;"	f	typeref:typename:void
serializer	proximity.cpp	/^template<> void serializer<vector<Min<Node*> > >(vector<Min<Node*> >& x, Serialize& s, const str/;"	f	typeref:typename:void
serializer	util.cpp	/^template<> void serializer<Mat2x2>(Mat2x2& x, Serialize& s,const string& n) { return serializer_/;"	f	typeref:typename:void
serializer	util.cpp	/^template<> void serializer<Mat3x3>(Mat3x3& x, Serialize& s,const string& n) { return serializer_/;"	f	typeref:typename:void
serializer	util.cpp	/^template<> void serializer<Vec2>(Vec2& x, Serialize& s,const string& n) { return serializer_vec(/;"	f	typeref:typename:void serializer void serializer void serializer void
serializer	util.cpp	/^template<> void serializer<Vec3>(Vec3& x, Serialize &s,const string& n) { return serializer_vec(/;"	f	typeref:typename:void
serializer	util.cpp	/^template<> void serializer<vector<Vec3> >(vector<Vec3>& x, Serialize& s, const string& n) { retu/;"	f	typeref:typename:void
serializer	util.cpp	/^template<> void serializer<vector<double> >(vector<double>& x, Serialize& s, const string& n) { /;"	f	typeref:typename:void
serializer	util.cpp	/^void serializer(T& v, Serialize& s, const string& name) { $/;"	f	typeref:typename:void
serializer_array	util.hpp	/^void serializer_array(std::vector<T>& v, Serialize& s, const std::string& name) { $/;"	f	typeref:typename:void
serializer_dvec	util.cpp	/^void serializer_dvec(vector<T>& v, Serialize& s, const string& name) { $/;"	f	typeref:typename:void
serializer_mat	util.cpp	/^void serializer_mat(Mat<n,n>& x, Serialize& s, const string& name) { $/;"	f	typeref:typename:void
serializer_vec	util.cpp	/^void serializer_vec(Vec<n>& x, Serialize& s, const string& name) { $/;"	f	typeref:typename:void
serializer_vec	vectors.hpp	/^tpl void serializer_vec(gzFile fp, VecnT& v, bool save) { for(int i=0; i<3; i++) serializer(fp, /;"	f	typeref:typename:tpl void
set_flag	subset.cpp	/^void MeshSubset::set_flag(int flag) {$/;"	f	class:MeshSubset	typeref:typename:void
set_indices	mesh.cpp	/^void set_indices (Mesh &mesh) {$/;"	f	typeref:typename:void
set_indices	mesh.cpp	/^void set_indices (vector<Mesh*>& meshes) {$/;"	f	typeref:typename:void
set_null	remesh.cpp	/^void RemeshOp::set_null(std::vector<Edge*>& v) {$/;"	f	class:RemeshOp	typeref:typename:void
set_row	vectors.hpp	/^    void set_row(int i, const VecnT& v) { for(int col = 0; col < n; ++col) c[col][i] = v[col]; }$/;"	f	class:Mat	typeref:typename:void
set_submat	optimization.hpp	/^inline void set_submat (SpMat<double> &A, int i, int j, const Mat3x3 &Aij) {$/;"	f	typeref:typename:void
set_subvec	optimization.hpp	/^inline void set_subvec (double *x, int i, const Vec3 &xi) {$/;"	f	typeref:typename:void
set_subvec	optimization.hpp	/^template <int n> void set_subvec (double *x, int i, const Vec<n> &xi) {$/;"	f	typeref:typename:void
set_unsigned_ee_distance	geometry.cpp	/^bool set_unsigned_ee_distance (const Vec3 &x0, const Vec3 &x1,$/;"	f	typeref:typename:bool
set_unsigned_ve_distance	geometry.cpp	/^bool set_unsigned_ve_distance (const Vec3 &x, const Vec3 &y0, const Vec3 &y1,$/;"	f	typeref:typename:bool
set_unsigned_vf_distance	geometry.cpp	/^bool set_unsigned_vf_distance (const Vec3 &x,$/;"	f	typeref:typename:bool
sg	strainlimiting.cpp	/^    mutable vector<Mat3x3> sg;$/;"	m	struct:SLOpt	typeref:typename:vector<Mat3x3>	file:
sgn	util.hpp	/^template <typename T> T sgn (const T &x) {return x<0 ? -1 : 1;}$/;"	f	typeref:typename:T
should_flip	dynamicremesh.cpp	/^bool should_flip (const Edge *edge) {$/;"	f	typeref:typename:bool
should_flip2	dynamicremesh.cpp	/^inline bool should_flip2 (const Vec2& x, const Vec2& y, const Vec2& z, const Vec2& w, $/;"	f	typeref:typename:bool
shrink_face	display.cpp	/^void shrink_face (const Face *face, double shrink_factor, double shrink_max,$/;"	f	typeref:typename:void
sigma	mesh.hpp	/^    Mat3x3 sigma;$/;"	m	struct:Face	typeref:typename:Mat3x3
signed_ee_distance	geometry.cpp	/^double signed_ee_distance (const Vec3 &x0, const Vec3 &x1,$/;"	f	typeref:typename:double
signed_ve_distance	geometry.cpp	/^double signed_ve_distance (const Vec3 &x,const Vec3 &y0, const Vec3 &y1,$/;"	f	typeref:typename:double
signed_vf_distance	geometry.cpp	/^double signed_vf_distance (const Vec3 &x,$/;"	f	typeref:typename:double
sim	runphysics.cpp	/^Simulation sim;$/;"	v	typeref:typename:Simulation
sim_step	runphysics.cpp	/^void sim_step() {$/;"	f	typeref:typename:void
single_step	simulation.cpp	/^bool single_step = false;$/;"	v	typeref:typename:bool
singular_value_decomposition	vectors.cpp	/^template <int m, int n> SVD<m,n> singular_value_decomposition (const Mat<m,n> &A) {$/;"	f	typeref:typename:SVD<m,n>
singular_value_decomposition	vectors.cpp	/^template<> SVD<3,2> singular_value_decomposition<3,2> (const Mat<3,2> &A) {$/;"	f	typeref:typename:SVD<3,2>
size_max	cloth.hpp	/^    double size_min, size_max, size_uniform; \/\/ size limits$/;"	m	struct:Remeshing	typeref:typename:double
size_min	cloth.hpp	/^    double size_min, size_max, size_uniform; \/\/ size limits$/;"	m	struct:Remeshing	typeref:typename:double
size_uniform	cloth.hpp	/^    double size_min, size_max, size_uniform; \/\/ size limits$/;"	m	struct:Remeshing	typeref:typename:double
sizing	mesh.hpp	/^    Mat3x3 sizing;$/;"	m	struct:Vert	typeref:typename:Mat3x3
snprintf	winport.hpp	/^#define snprintf /;"	d
solve_cubic	collision.cpp	/^int solve_cubic (double a, double b, double c, double d, double x[3]) {$/;"	f	typeref:typename:int
solve_ixns	separateobs.cpp	/^void solve_ixns (const vector<Ixn> &ixns) {$/;"	f	namespace:SO	typeref:typename:void
solve_llsq	vectors.cpp	/^template <int m, int n> Vec<n> solve_llsq(const Mat<m,n> &A, const Vec<m>& b) {$/;"	f	typeref:typename:Vec<n>
solve_quadratic	util.cpp	/^int solve_quadratic (double a, double b, double c, double x[2]) {$/;"	f	typeref:typename:int
solve_symmetric	vectors.cpp	/^template<> Vec2 solve_symmetric(const Mat2x2& A, const Vec2& b) {$/;"	f
solve_symmetric	vectors.cpp	/^template<> Vec3 solve_symmetric(const Mat3x3& A, const Vec3& b) {$/;"	f	typeref:typename:Vec3
sort	util.cpp	/^void Stats::sort () const {$/;"	f	class:Stats	typeref:typename:void
sorted	util.hpp	/^    mutable bool sorted;$/;"	m	struct:Stats	typeref:typename:bool
sparse_to_taucs	taucs.cpp	/^taucs_ccs_matrix *sparse_to_taucs (const SpMat<double> &As) {$/;"	f	typeref:typename:taucs_ccs_matrix *
sparse_to_taucs	taucs.cpp	/^template <int m> taucs_ccs_matrix *sparse_to_taucs (const SpMat< Mat<m,m> > &As) {$/;"	f	typeref:typename:taucs_ccs_matrix *
special	display.hpp	/^    void (*special) (int, int, int);$/;"	m	struct:GlutCallbacks	typeref:typename:void (*)(int,int,int)
special	displayreplay.cpp	/^static void special (int key, int x, int y) {$/;"	f	typeref:typename:void	file:
split_edge	remesh.cpp	/^RemeshOp split_edge (Edge* edge, double d) {$/;"	f	typeref:typename:RemeshOp
split_edge_with_plane	breaking.cpp	/^Edge* split_edge_with_plane(Face* face, Node* node, Vec3& n) {$/;"	f	typeref:typename:Edge *
split_meshes	misc.cpp	/^void split_meshes (const vector<string> &args) {$/;"	f	typeref:typename:void
split_sector	breaking.cpp	/^void split_sector(Node* node, Edge* start, Edge* end, MeshSubset& subset) {$/;"	f	typeref:typename:void
split_worst_edge	dynamicremesh.cpp	/^bool split_worst_edge (MeshSubset* subset, const vector<Edge*>& edges) {$/;"	f	typeref:typename:bool
sq	vectors.hpp	/^inline double sq (double x) {return x*x;}$/;"	f	typeref:typename:double
sqr	util.hpp	/^template <typename T> T sqr (const T& x) { return x*x; }$/;"	f	typeref:typename:T
sqrt	dynamicremesh.cpp	/^template <int n> Mat<n,n> sqrt (const Mat<n,n> &A) {$/;"	f	typeref:typename:Mat<n,n>
sqrt	winport.hpp	/^inline double sqrt(int n) { return sqrt(double(n)); }$/;"	f	typeref:typename:double
start_time	handle.hpp	/^    double start_time, end_time, fade_time;$/;"	m	struct:Handle	typeref:typename:double
start_time	obstacle.hpp	/^    double start_time, end_time;$/;"	m	struct:Obstacle	typeref:typename:double
static_assert	vectors.hpp	/^#define static_assert(/;"	d
static_assertion_failure	vectors.hpp	/^template <> struct static_assertion_failure<true> {void operator() () {}};$/;"	s
static_remesh	dynamicremesh.cpp	/^void static_remesh (Mesh& mesh) {$/;"	f	typeref:typename:void
step	simulation.hpp	/^    int frame, step;$/;"	m	struct:Simulation	typeref:typename:int
stepDebug	display.cpp	/^bool stepDebug;$/;"	v	typeref:typename:bool
step_mesh	simulation.cpp	/^void step_mesh (Mesh &mesh, double dt) {$/;"	f	typeref:typename:void
step_time	simulation.hpp	/^    double frame_time, step_time;$/;"	m	struct:Simulation	typeref:typename:double
stiff	constraint.hpp	/^    double stiff;$/;"	m	struct:EqCon	typeref:typename:double
stiff	constraint.hpp	/^    double stiff;$/;"	m	struct:GlueCon	typeref:typename:double
stiff	constraint.hpp	/^    double stiff;$/;"	m	struct:IneqCon	typeref:typename:double
stp	vectors.hpp	/^template <typename T> T stp (const Vec<3,T> &u, const Vec<3,T> &v, const Vec<3,T> &w) {return do/;"	f	typeref:typename:T
strain_color	display.cpp	/^Vec3 strain_color (const Face *face) {$/;"	f	typeref:typename:Vec3
strain_con	strainlimiting.cpp	/^double strain_con (const SLOpt &sl, const double *x, int j, int &sign) {$/;"	f	typeref:typename:double
strain_con_grad	strainlimiting.cpp	/^void strain_con_grad (const SLOpt &sl, const double *x, int j, double factor,$/;"	f	typeref:typename:void
strain_limiting	strainlimiting.cpp	/^void strain_limiting (vector<Mesh*> &meshes, const vector<StrainLimit> &strain_limits,$/;"	f	typeref:typename:void
strain_limits	strainlimiting.cpp	/^    const vector<StrainLimit> &strain_limits;$/;"	m	struct:SLOpt	typeref:typename:const vector<StrainLimit> &	file:
strain_max	cloth.hpp	/^    double strain_min, strain_max; \/\/ strain limits$/;"	m	struct:Material	typeref:typename:double
strain_min	cloth.hpp	/^    double strain_min, strain_max; \/\/ strain limits$/;"	m	struct:Material	typeref:typename:double
strainlimiting	simulation.cpp	/^                 strainlimiting = Simulation::StrainLimiting,$/;"	v	typeref:typename:const int	file:
strainlimiting_step	simulation.cpp	/^void strainlimiting_step (Simulation &sim, const vector<Constraint*> &cons) {$/;"	f	typeref:typename:void
strainzeroing_step	simulation.cpp	/^void strainzeroing_step (Simulation &sim) {$/;"	f	typeref:typename:void
strength	handle.hpp	/^    double strength (double t) {$/;"	f	struct:Handle	typeref:typename:double
stretch_plasticity_from_embedding	plasticity.cpp	/^Mat3x3 stretch_plasticity_from_embedding(const Face *face) {$/;"	f	typeref:typename:Mat3x3
stretching_energy	physics.cpp	/^double stretching_energy (const Face *face) {$/;"	f	typeref:typename:double
stretching_force	physics.cpp	/^pair<Mat9x9,Vec9> stretching_force (const Face *face) {$/;"	f	typeref:typename:pair<Mat9x9,Vec9>
stretching_stiffness	dde.cpp	/^Vec4 stretching_stiffness (const Mat2x2 &G, const StretchingSamples &samples) {$/;"	f	typeref:typename:Vec4
stringf	util.cpp	/^inline string stringf (const string &format, ...) {$/;"	f	typeref:typename:string
submat3	physics.cpp	/^template <int m, int n> Mat<3,3> submat3 (const Mat<m,n> &A, int i, int j) {$/;"	f	typeref:typename:Mat<3,3>
subset	util.hpp	/^inline bool subset (const std::vector<T> &xs, const std::vector<T> &ys) {$/;"	f	typeref:typename:bool
subvec3	physics.cpp	/^template <int n> Vec<3> subvec3 (const Vec<n> &b, int i) {$/;"	f	typeref:typename:Vec<3>
sum	util.hpp	/^    double sum;$/;"	m	struct:Stats	typeref:typename:double
support_nodes	subset.hpp	/^	std::vector<Node*> support_nodes;$/;"	m	class:MeshSubset	typeref:typename:std::vector<Node * >
symmetrize	blockvectors.hpp	/^template <> inline Mat<3,4> symmetrize<2> () {$/;"	f	typeref:typename:Mat<3,4>
t	collision.cpp	/^    double t;$/;"	m	struct:Impact	typeref:typename:double	file:
t	separate.cpp	/^    double t[2];$/;"	m	struct:EdgeClipping	typeref:typename:double[2]	file:
t	spline.hpp	/^    struct Point {double t; T x, v;};$/;"	m	struct:Spline::Point	typeref:typename:double
t	vectors.hpp	/^    MatnmT t () const {return transpose(*this);}$/;"	f	class:Mat	typeref:typename:MatnmT
t	vectors.hpp	/^    const Mat<m,n,T>& t () const {return static_cast<const Mat<m, n, T>&>(*this);}$/;"	f	class:MatTransposed	typeref:typename:const Mat<m,n,T> &
t0	sepstrength.cpp	/^	Vec3 t0, t1;$/;"	m	struct:FanPrecomp	typeref:typename:Vec3	file:
t1	sepstrength.cpp	/^	Vec3 t0, t1;$/;"	m	struct:FanPrecomp	typeref:typename:Vec3	file:
tail	tensormax.cpp	/^template <typename T> vector<T> tail (const vector<T> &v) {$/;"	f	typeref:typename:vector<T>
targets	morph.hpp	/^    std::vector<Mesh> targets;$/;"	m	struct:Morph	typeref:typename:std::vector<Mesh>
taucs_linear_solve	taucs.cpp	/^template <int m> vector< Vec<m> > taucs_linear_solve$/;"	f	typeref:typename:vector<Vec<m>>
taucs_linear_solve	taucs.cpp	/^vector<double> taucs_linear_solve (const SpMat<double> &A, const vector<double> &b) {$/;"	f	typeref:typename:vector<double>
tensor_max	tensormax.cpp	/^Mat2x2 tensor_max (const vector<Mat2x2> &Ms) {$/;"	f	typeref:typename:Mat2x2
test_state	io.hpp	/^void test_state (T& state, const std::string& prefix) {$/;"	f	typeref:typename:void
then	timer.hpp	/^    boost::posix_time::ptime then;$/;"	m	struct:Timer	typeref:typename:boost::posix_time::ptime
theta_ideal	mesh.hpp	/^    double theta_ideal, damage; \/\/ rest dihedral angle, damage parameter$/;"	m	struct:Edge	typeref:typename:double
theta_ideal	remesh.cpp	/^    vector<double> theta_ideal;$/;"	m	struct:PlasticityStash	typeref:typename:vector<double>	file:
thickness	cloth.hpp	/^    double thickness;$/;"	m	struct:Material	typeref:typename:double
thickness	collision.cpp	/^static const double &thickness = ::magic.projection_thickness;$/;"	v	typeref:typename:const double &	file:
thickness	separate.cpp	/^static const double &thickness = ::magic.projection_thickness;$/;"	v	typeref:typename:const double &	file:
tick	timer.cpp	/^void Timer::tick () {$/;"	f	class:Timer	typeref:typename:void
time	simulation.hpp	/^    double time;$/;"	m	struct:Simulation	typeref:typename:double
timers	simulation.hpp	/^    Timer timers[nModules];$/;"	m	struct:Simulation	typeref:typename:Timer[]
timingfile	runphysics.cpp	/^static fstream timingfile;$/;"	v	typeref:typename:fstream	file:
to_axisangle	transformation.cpp	/^pair<Vec3, double> Quaternion::to_axisangle() const {$/;"	f	class:Quaternion	typeref:typename:pair<Vec3,double>
tock	timer.cpp	/^void Timer::tock () {$/;"	f	class:Timer	typeref:typename:void
total	timer.hpp	/^    double last, total;$/;"	m	struct:Timer	typeref:typename:double
toughness	cloth.hpp	/^    double toughness, fracture_bend_thickness; \/\/ fracture toughness$/;"	m	struct:Material	typeref:typename:double
tpl	vectors.hpp	/^#define tpl /;"	d
trace	vectors.hpp	/^template <int n, typename T> T trace (const MatnnT &A) {T t = 0; for (int j = 0; j < n; j++) t +/;"	f	typeref:typename:T
transform_spline	obstacle.hpp	/^    const Motion *transform_spline;$/;"	m	struct:Obstacle	typeref:typename:const Motion *
translation	transformation.hpp	/^    Vec3 translation;$/;"	m	struct:Transformation	typeref:typename:Vec3
transpose	blockvectors.hpp	/^template <int m, int n> Mat<m*n,m*n,double> transpose () {$/;"	f	typeref:typename:Mat<m * n,m * n,double>
transpose	vectors.hpp	/^tpl MatnmT transpose (const MatmnT &A) {MatnmT B; for (int i = 0; i < m; i++) for (int j = 0; j /;"	f	typeref:typename:tpl MatnmT
tree	collisionutil.hpp	/^    BVHTree tree;$/;"	m	struct:AccelStruct	typeref:typename:BVHTree
tri2obj	misc.cpp	/^void tri2obj (const vector<string> &args) {$/;"	f	typeref:typename:void
triangle_ray_test	geometry.cpp	/^bool triangle_ray_test (const Vec3 &x0, const Vec3& x1, const Vec3& x2,$/;"	f	typeref:typename:Plane plane_fit Plane plane_fit bool
triangle_to_obj	io.cpp	/^void triangle_to_obj (const string &inname, const string &outname) {$/;"	f	typeref:typename:void
triangulate	io.cpp	/^vector<Face*> triangulate (const vector<Vert*> &verts) {$/;"	f	typeref:typename:vector<Face * >
trust_region_method	trustregion.cpp	/^void trust_region_method (const NLOpt &problem, OptOptions opt, bool verbose) {$/;"	f	typeref:typename:void
try_edge_collapse	dynamicremesh.cpp	/^RemeshOp try_edge_collapse (Edge *edge, int which) {$/;"	f	typeref:typename:RemeshOp
try_move_node	remesh.cpp	/^bool try_move_node (Node* node, Edge* edge, double d) {$/;"	f	typeref:typename:bool
type	collision.cpp	/^    enum Type {VF, EE} type;$/;"	m	struct:Impact	typeref:enum:Impact::Type	file:
u	handle.hpp	/^    Vec2 u;$/;"	m	struct:CircleHandle	typeref:typename:Vec2
u	mesh.hpp	/^    Vec3 u; \/\/ material space$/;"	m	struct:Vert	typeref:typename:Vec3
uint	util.hpp	/^typedef unsigned int uint;$/;"	t	typeref:typename:unsigned int
umax	conf.cpp	/^    Vec2 umin, umax;$/;"	m	struct:Box	typeref:typename:Vec2	file:
umin	conf.cpp	/^    Vec2 umin, umax;$/;"	m	struct:Box	typeref:typename:Vec2	file:
unify	separate.cpp	/^    void unify (size_t x, size_t y) {$/;"	f	struct:UnionFind	typeref:typename:void	file:
unsigned_ee_distance	geometry.cpp	/^double unsigned_ee_distance (const Vec3 &x0, const Vec3 &x1,$/;"	f	typeref:typename:double
unsigned_vf_distance	geometry.cpp	/^double unsigned_vf_distance (const Vec3 &x,$/;"	f	typeref:typename:double
update	localopt.cpp	/^void LocalOpt<s>::update(const double* x) const {$/;"	f	class:LocalOpt	typeref:typename:void
update	proxy.cpp	/^void FloorProxy::update(Mesh& mesh) {$/;"	f	class:FloorProxy	typeref:typename:void
update	remesh.cpp	/^void RemeshOp::update(std::vector<Edge*>& v) {$/;"	f	class:RemeshOp	typeref:typename:void
update	remesh.cpp	/^void RemeshOp::update(std::vector<Face*>& v) {$/;"	f	class:RemeshOp	typeref:typename:void
update	remesh.cpp	/^void RemeshOp::update(std::vector<Node*>& v) {$/;"	f	class:RemeshOp	typeref:typename:void
update_accel_struct	collisionutil.cpp	/^void update_accel_struct (AccelStruct &acc) {$/;"	f	typeref:typename:void
update_active	collision.cpp	/^void update_active (const vector<AccelStruct*> &accs,$/;"	f	typeref:typename:void
update_active	separate.cpp	/^void update_active (const vector<AccelStruct*> &accs,$/;"	f	typeref:typename:void
update_active	separateobs.cpp	/^void update_active (const vector<AccelStruct*> &accs, const vector<Ixn> &ixns) {$/;"	f	namespace:SO	typeref:typename:void
update_nearest_point	nearobs.cpp	/^void update_nearest_point (const Vec3 &x, BVHNode *node, NearPoint &p) {$/;"	f	typeref:typename:void
update_nearest_point	nearobs.cpp	/^void update_nearest_point (const Vec3 &x, const Face *face, NearPoint &p) {$/;"	f	typeref:typename:void
update_obstacles	simulation.cpp	/^void update_obstacles (Simulation &sim, bool update_positions) {$/;"	f	typeref:typename:void
update_support	subset.cpp	/^void MeshSubset::update_support() {$/;"	f	class:MeshSubset	typeref:typename:void
update_velocities	simulation.cpp	/^void update_velocities (vector<Mesh*> &meshes, vector<Vec3> &xold, double dt) {$/;"	f	typeref:typename:void
update_x0	mesh.cpp	/^void update_x0 (Mesh &mesh) {$/;"	f	typeref:typename:void
use_dde	cloth.hpp	/^    bool use_dde; \/\/ use DDE material files$/;"	m	struct:Material	typeref:typename:bool
uuid	mesh.hpp	/^    int uuid;$/;"	m	struct:Node	typeref:typename:int
uuid_src	mesh.cpp	/^int uuid_src = 0;$/;"	v	typeref:typename:int
v	conf.cpp	/^struct Velocity {Vec3 v, w; Vec3 o;};$/;"	m	struct:Velocity	typeref:typename:Vec3	file:
v	mesh.hpp	/^    Vec3 x, x0, v; \/\/ position, old (collision-free) position, velocity$/;"	m	struct:Node	typeref:typename:Vec3
v	mesh.hpp	/^    Vert* v[3]; \/\/ verts$/;"	m	struct:Face	typeref:typename:Vert * [3]
v	spline.hpp	/^    struct Point {double t; T x, v;};$/;"	m	struct:Spline::Point	typeref:typename:T
v	transformation.hpp	/^    Vec3 v;$/;"	m	struct:Quaternion	typeref:typename:Vec3
val	nearobs.cpp	/^    T val;$/;"	m	struct:Min	typeref:typename:T	file:
val	proximity.cpp	/^    T val;$/;"	m	struct:Min	typeref:typename:T	file:
validate_handles	simulation.cpp	/^void validate_handles (const Simulation &sim) {$/;"	f	typeref:typename:void
value	constraint.cpp	/^double EqCon::value (int *sign) {$/;"	f	class:EqCon	typeref:typename:double
value	constraint.cpp	/^double GlueCon::value (int *sign) {$/;"	f	class:GlueCon	typeref:typename:double
value	constraint.cpp	/^double IneqCon::value (int *sign) {$/;"	f	class:IneqCon	typeref:typename:double
vec3f	bvh.hpp	/^typedef Vec3 vec3f;$/;"	t	typeref:typename:Vec3
vec_max	util.hpp	/^Vec<n,T> vec_max (const Vec<n,T> &u, const Vec<n,T> &v) {$/;"	f	typeref:typename:Vec<n,T>
vec_min	util.hpp	/^Vec<n,T> vec_min (const Vec<n,T> &u, const Vec<n,T> &v) {$/;"	f
vec_to_mat	blockvectors.hpp	/^Mat<m,n,T> vec_to_mat (const Vec<m*n,T> &a) {$/;"	f	typeref:typename:Mat<m,n,T>
vel	spline.cpp	/^T Spline<T>::vel (double t) const {$/;"	f	class:Spline	typeref:typename:T
velocity	simulation.hpp	/^    Vec3 velocity;$/;"	m	struct:Wind	typeref:typename:Vec3
verbose	dynamicremesh.cpp	/^static const bool verbose = false;$/;"	v	typeref:typename:const bool	file:
verbose	lsnewton.cpp	/^static bool verbose;$/;"	v	typeref:typename:bool	file:
verbose	physics.cpp	/^static const bool verbose = false;$/;"	v	typeref:typename:const bool	file:
verbose	simulation.cpp	/^static const bool verbose = false;$/;"	v	typeref:typename:const bool	file:
version	util.hpp	/^	int version;$/;"	m	struct:Serialize	typeref:typename:int
vert_box	bvh.cpp	/^BOX vert_box (const Vert *vert, bool ccd) {$/;"	f	typeref:typename:BOX
vertex	display.cpp	/^void vertex (const Vec2 &x) {$/;"	f	typeref:typename:void
vertex	display.cpp	/^void vertex (const Vec3 &x) {$/;"	f	typeref:typename:void
verts	mesh.hpp	/^    std::vector<Vert*> verts;$/;"	m	struct:Mesh	typeref:typename:std::vector<Vert * >
verts	mesh.hpp	/^    std::vector<Vert*> verts;$/;"	m	struct:Node	typeref:typename:std::vector<Vert * >
vf_clear_distance	separateobs.cpp	/^double vf_clear_distance (const Face *face0, const Face *face1, const Vec3 &d,$/;"	f	namespace:SO	typeref:typename:double
vf_collision_test	collision.cpp	/^bool vf_collision_test (const Vert *vert, const Face *face, Impact &impact) {$/;"	f	typeref:typename:bool
violation	constraint.cpp	/^double violation (double value) {return std::max(-value, 0.);}$/;"	f	typeref:typename:double
volume	bvh.hpp	/^	FORCEINLINE float volume() const { return width()*height()*depth(); }$/;"	f	class:kDOP18	typeref:typename:FORCEINLINE float
w	collision.cpp	/^    double w[4];$/;"	m	struct:Impact	typeref:typename:double[4]	file:
w	conf.cpp	/^struct Velocity {Vec3 v, w; Vec3 o;};$/;"	m	struct:Velocity	typeref:typename:Vec3	file:
w	constraint.hpp	/^    double w[4];$/;"	m	struct:IneqCon	typeref:typename:double[4]
wait_key	display.cpp	/^void wait_key () {   $/;"	f	typeref:typename:void
weakening	cloth.hpp	/^    double yield_curv, weakening; \/\/ plasticity parameters$/;"	m	struct:Material	typeref:typename:double
wedge	vectors.hpp	/^template <typename T> T wedge (const Vec<2,T> &u, const Vec<2,T> &v) {return u[0]*v[1] - u[1]*v[/;"	f	typeref:typename:T
weights	morph.hpp	/^    Spline<Weights> weights;$/;"	m	struct:Morph	typeref:typename:Spline<Weights>
welzls_algorithm	tensormax.cpp	/^Disk welzls_algorithm (const vector<Disk> &disks) {$/;"	f	typeref:typename:Disk
width	bvh.hpp	/^	FORCEINLINE float width()  const { return _dist[9] - _dist[0]; }$/;"	f	class:kDOP18	typeref:typename:FORCEINLINE float
wind	simulation.hpp	/^    Wind wind;$/;"	m	struct:Simulation	typeref:typename:Wind
wind_force	physics.cpp	/^Vec3 wind_force (const Face *face, const Wind &wind) {$/;"	f	typeref:typename:Vec3
window	display.hpp	/^    int window, parent;$/;"	m	struct:Pane	typeref:typename:int
world	display.hpp	/^	static Pane& world() { return panes[2]; }$/;"	f	struct:Pane	typeref:typename:Pane &
write_motion_file	mot_parser.cpp	/^void write_motion_file(BodyVector &bodies, const string& filename) {$/;"	f	typeref:typename:void
write_motion_file	mot_parser.cpp	/^void write_motion_file(BodyVector &bodies, ostream& ostr) {$/;"	f	typeref:typename:void
x	constraint.hpp	/^    Vec3 x, n;$/;"	m	struct:EqCon	typeref:typename:Vec3
x	display.cpp	/^    int x, y;$/;"	m	struct:MouseState	typeref:typename:int	file:
x	mesh.hpp	/^    Vec3 x, x0, v; \/\/ position, old (collision-free) position, velocity$/;"	m	struct:Node	typeref:typename:Vec3
x	nearobs.cpp	/^    Vec3 x;$/;"	m	struct:NearPoint	typeref:typename:Vec3	file:
x	spline.hpp	/^    struct Point {double t; T x, v;};$/;"	m	struct:Spline::Point	typeref:typename:T
x0	handle.hpp	/^    Vec3 x0;$/;"	m	struct:NodeHandle	typeref:typename:Vec3
x0	localopt.cpp	/^    vector<Vec3> x0;$/;"	m	struct:LocalOpt	typeref:typename:vector<Vec3>	file:
x0	mesh.hpp	/^    Vec3 x, x0, v; \/\/ position, old (collision-free) position, velocity$/;"	m	struct:Node	typeref:typename:Vec3
x0	mesh.hpp	/^    Vec3 x0, n;$/;"	m	struct:Plane	typeref:typename:Vec3
x0	popfilter.cpp	/^    vector<Vec3> x0, a0;$/;"	m	struct:PopOpt	typeref:typename:vector<Vec3>	file:
xc	handle.hpp	/^    Vec3 xc, dx0, dx1;$/;"	m	struct:CircleHandle	typeref:typename:Vec3
xold	collision.cpp	/^static map<const Node*, Vec3> xold;$/;"	v	typeref:typename:map<const Node *,Vec3>	file:
xold	separateobs.cpp	/^static map<const Node*, Vec3> xold;$/;"	v	namespace:SO	typeref:typename:map<const Node *,Vec3>	file:
xold	strainlimiting.cpp	/^    vector<Vec3> xold;$/;"	m	struct:SLOpt	typeref:typename:vector<Vec3>	file:
xs	util.hpp	/^    mutable std::vector<double> xs;$/;"	m	struct:Stats	typeref:typename:std::vector<double>
y	display.cpp	/^    int x, y;$/;"	m	struct:MouseState	typeref:typename:int	file:
y	mesh.hpp	/^    Vec3 y; \/\/ plastic embedding$/;"	m	struct:Node	typeref:typename:Vec3
y0	plasticity.cpp	/^    vector<Vec3> y0;$/;"	m	struct:EmbedOpt	typeref:typename:vector<Vec3>	file:
yield_curv	cloth.hpp	/^    double yield_curv, weakening; \/\/ plasticity parameters$/;"	m	struct:Material	typeref:typename:double
yield_stretch	cloth.hpp	/^    double yield_stretch, plastic_flow, plastic_limit;$/;"	m	struct:Material	typeref:typename:double
zone	collision.cpp	/^    ImpactZone *zone;$/;"	m	struct:NormalOpt	typeref:typename:ImpactZone *	file:
zoom	display.cpp	/^void zoom (bool in) {$/;"	f	typeref:typename:void
~CollisionProxy	proxy.hpp	/^    virtual ~CollisionProxy() {};$/;"	f	class:CollisionProxy
~Constraint	constraint.hpp	/^    virtual ~Constraint () {};$/;"	f	struct:Constraint
~DeformBVHNode	bvh.cpp	/^DeformBVHNode::~DeformBVHNode()$/;"	f	class:DeformBVHNode
~DeformBVHTree	bvh.cpp	/^DeformBVHTree::~DeformBVHTree()$/;"	f	class:DeformBVHTree
~Handle	handle.hpp	/^    virtual ~Handle () {};$/;"	f	struct:Handle
